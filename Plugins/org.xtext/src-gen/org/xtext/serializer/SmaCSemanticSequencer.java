/*
 * generated by Xtext 2.34.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.xtext.services.SmaCGrammarAccess;
import org.xtext.smaC.AbstractContract;
import org.xtext.smaC.Assert;
import org.xtext.smaC.Clause;
import org.xtext.smaC.Company;
import org.xtext.smaC.Condition;
import org.xtext.smaC.Constructor;
import org.xtext.smaC.Contract;
import org.xtext.smaC.DeclarationFunctionAbstractContract;
import org.xtext.smaC.DeclarationFunctionInterface;
import org.xtext.smaC.DoWhileLoop;
import org.xtext.smaC.Event;
import org.xtext.smaC.File;
import org.xtext.smaC.ForLoop;
import org.xtext.smaC.Import;
import org.xtext.smaC.InputParam;
import org.xtext.smaC.Interface;
import org.xtext.smaC.Library;
import org.xtext.smaC.Mapping;
import org.xtext.smaC.MappingDeclaration;
import org.xtext.smaC.Modifier;
import org.xtext.smaC.OutputParam;
import org.xtext.smaC.OverrideModifier;
import org.xtext.smaC.PersonalizedStruct;
import org.xtext.smaC.PropertyAddress;
import org.xtext.smaC.PropertyBoolean;
import org.xtext.smaC.PropertyBytes;
import org.xtext.smaC.PropertyCompany;
import org.xtext.smaC.PropertyFloat;
import org.xtext.smaC.PropertyIdentifier;
import org.xtext.smaC.PropertyInteger;
import org.xtext.smaC.PropertyString;
import org.xtext.smaC.PropertyUInteger;
import org.xtext.smaC.PropertyUser;
import org.xtext.smaC.Restriction;
import org.xtext.smaC.RestrictionGas;
import org.xtext.smaC.SmaCPackage;
import org.xtext.smaC.User;
import org.xtext.smaC.Version;
import org.xtext.smaC.WhileLoop;

@SuppressWarnings("all")
public class SmaCSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SmaCGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SmaCPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SmaCPackage.ABSTRACT_CONTRACT:
				sequence_AbstractContract(context, (AbstractContract) semanticObject); 
				return; 
			case SmaCPackage.ASSERT:
				sequence_Assert(context, (Assert) semanticObject); 
				return; 
			case SmaCPackage.CLAUSE:
				sequence_Clause(context, (Clause) semanticObject); 
				return; 
			case SmaCPackage.COMPANY:
				sequence_Company(context, (Company) semanticObject); 
				return; 
			case SmaCPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case SmaCPackage.CONSTRUCTOR:
				sequence_Constructor(context, (Constructor) semanticObject); 
				return; 
			case SmaCPackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case SmaCPackage.DECLARATION_FUNCTION_ABSTRACT_CONTRACT:
				sequence_DeclarationFunctionAbstractContract(context, (DeclarationFunctionAbstractContract) semanticObject); 
				return; 
			case SmaCPackage.DECLARATION_FUNCTION_INTERFACE:
				sequence_DeclarationFunctionInterface(context, (DeclarationFunctionInterface) semanticObject); 
				return; 
			case SmaCPackage.DO_WHILE_LOOP:
				sequence_DoWhileLoop(context, (DoWhileLoop) semanticObject); 
				return; 
			case SmaCPackage.ENUM:
				sequence_Enum(context, (org.xtext.smaC.Enum) semanticObject); 
				return; 
			case SmaCPackage.ERROR:
				sequence_Error(context, (org.xtext.smaC.Error) semanticObject); 
				return; 
			case SmaCPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case SmaCPackage.FILE:
				sequence_File(context, (File) semanticObject); 
				return; 
			case SmaCPackage.FOR_LOOP:
				sequence_ForLoop(context, (ForLoop) semanticObject); 
				return; 
			case SmaCPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case SmaCPackage.INPUT_PARAM:
				sequence_InputParam(context, (InputParam) semanticObject); 
				return; 
			case SmaCPackage.INTERFACE:
				sequence_Interface(context, (Interface) semanticObject); 
				return; 
			case SmaCPackage.LIBRARY:
				sequence_Library(context, (Library) semanticObject); 
				return; 
			case SmaCPackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case SmaCPackage.MAPPING_DECLARATION:
				sequence_MappingDeclaration(context, (MappingDeclaration) semanticObject); 
				return; 
			case SmaCPackage.MODIFIER:
				sequence_Modifier(context, (Modifier) semanticObject); 
				return; 
			case SmaCPackage.OUTPUT_PARAM:
				sequence_OutputParam(context, (OutputParam) semanticObject); 
				return; 
			case SmaCPackage.OVERRIDE_MODIFIER:
				sequence_OverrideModifier(context, (OverrideModifier) semanticObject); 
				return; 
			case SmaCPackage.PERSONALIZED_STRUCT:
				sequence_PersonalizedStruct(context, (PersonalizedStruct) semanticObject); 
				return; 
			case SmaCPackage.PROPERTY_ADDRESS:
				sequence_PropertyAddress(context, (PropertyAddress) semanticObject); 
				return; 
			case SmaCPackage.PROPERTY_BOOLEAN:
				sequence_PropertyBoolean(context, (PropertyBoolean) semanticObject); 
				return; 
			case SmaCPackage.PROPERTY_BYTES:
				sequence_PropertyBytes(context, (PropertyBytes) semanticObject); 
				return; 
			case SmaCPackage.PROPERTY_COMPANY:
				sequence_PropertyCompany(context, (PropertyCompany) semanticObject); 
				return; 
			case SmaCPackage.PROPERTY_FLOAT:
				sequence_PropertyFloat(context, (PropertyFloat) semanticObject); 
				return; 
			case SmaCPackage.PROPERTY_IDENTIFIER:
				sequence_PropertyIdentifier(context, (PropertyIdentifier) semanticObject); 
				return; 
			case SmaCPackage.PROPERTY_INTEGER:
				sequence_PropertyInteger(context, (PropertyInteger) semanticObject); 
				return; 
			case SmaCPackage.PROPERTY_STRING:
				sequence_PropertyString(context, (PropertyString) semanticObject); 
				return; 
			case SmaCPackage.PROPERTY_UINTEGER:
				sequence_PropertyUInteger(context, (PropertyUInteger) semanticObject); 
				return; 
			case SmaCPackage.PROPERTY_USER:
				sequence_PropertyUser(context, (PropertyUser) semanticObject); 
				return; 
			case SmaCPackage.RESTRICTION:
				sequence_Restriction(context, (Restriction) semanticObject); 
				return; 
			case SmaCPackage.RESTRICTION_GAS:
				sequence_RestrictionGas(context, (RestrictionGas) semanticObject); 
				return; 
			case SmaCPackage.USER:
				sequence_User(context, (User) semanticObject); 
				return; 
			case SmaCPackage.VERSION:
				sequence_Version(context, (Version) semanticObject); 
				return; 
			case SmaCPackage.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns AbstractContract
	 *     AbstractContract returns AbstractContract
	 *
	 * Constraint:
	 *     (
	 *         name=Identifier 
	 *         superType+=[Element|ID]* 
	 *         modifiers+=Modifier* 
	 *         events+=Event* 
	 *         errors+=Error* 
	 *         clauses+=DeclarationFunctionAbstractContract*
	 *     )
	 * </pre>
	 */
	protected void sequence_AbstractContract(ISerializationContext context, AbstractContract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RestrictionClause returns Assert
	 *     Assert returns Assert
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             expr1=SyntaxExpression | 
	 *             expr1=Identifier | 
	 *             expr1=NumberExpression | 
	 *             expr1=ArithmeticalExpression | 
	 *             expr1=BracketExpression | 
	 *             expr1=MSGSENDER | 
	 *             expr1=MSGVALUE | 
	 *             expr1='now' | 
	 *             expr1=IdentifierValueExpression | 
	 *             expr1=SyntaxExpression | 
	 *             expr1=Identifier | 
	 *             expr1=NumberExpression | 
	 *             expr1=ArithmeticalExpression | 
	 *             expr1=MSGSENDER | 
	 *             expr1=MSGVALUE | 
	 *             expr1=BlockVariables | 
	 *             expr1='now'
	 *         ) 
	 *         (
	 *             operator=ComparationOperator 
	 *             (
	 *                 expr2=SyntaxExpression | 
	 *                 expr2=Identifier | 
	 *                 expr2=NumberExpression | 
	 *                 expr2=ArithmeticalExpression | 
	 *                 expr2=MSGSENDER | 
	 *                 expr2=MSGVALUE | 
	 *                 expr2='now'
	 *             )
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_Assert(ISerializationContext context, Assert semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Clause returns Clause
	 *
	 * Constraint:
	 *     (
	 *         name=Identifier 
	 *         inputParams+=InputParam* 
	 *         constant=CONSTANT? 
	 *         virtual=VIRTUAL? 
	 *         visibilityAccess=Visibility 
	 *         (personalizedModifier+=[Modifier|ID] inputParamsModifier+=InputParam*)* 
	 *         predefinedModifier=InputModifier? 
	 *         override=OverrideModifier? 
	 *         outputParams+=OutputParam* 
	 *         (
	 *             (
	 *                 restriction+=RestrictionClause | 
	 *                 conditions+=Condition | 
	 *                 properties+=Properties | 
	 *                 mappingProperties+=Mapping | 
	 *                 undeterminedloops+=UnDeterminedLoop | 
	 *                 determinedloops+=ForLoop | 
	 *                 expressions+=Expression | 
	 *                 predefinedFunctions+=PredefinedFunctions
	 *             )? 
	 *             (event+=[Event|ID] inputParamsEvent+=InputParam*)?
	 *         )+
	 *     )
	 * </pre>
	 */
	protected void sequence_Clause(ISerializationContext context, Clause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Company returns Company
	 *
	 * Constraint:
	 *     (
	 *         name='Company' 
	 *         nameAttributeAddress=Identifier 
	 *         nameAttributeCompany=Identifier 
	 *         nameAttributeCity=Identifier 
	 *         emailAttributeCompany=Identifier 
	 *         properties+=Properties* 
	 *         mapping+=Mapping* 
	 *         structs+=PersonalizedStruct*
	 *     )
	 * </pre>
	 */
	protected void sequence_Company(ISerializationContext context, Company semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             condition=CryptographycFunctionsComparationExpresion | 
	 *             condition=LogicalComparationExpression | 
	 *             condition=ArithmeticalComparationExpression | 
	 *             condition=ComparationExpression | 
	 *             condition=BracketExpression | 
	 *             condition=IdentifierValueExpression | 
	 *             condition=NegationExpression | 
	 *             condition=CallFunctionExpression | 
	 *             condition=BoolValueExpression
	 *         ) 
	 *         restriction+=RestrictionClause? 
	 *         (
	 *             (
	 *                 properties+=Properties | 
	 *                 expressions+=Expression | 
	 *                 expressions+=BREAK | 
	 *                 expressions+=CONTINUE | 
	 *                 conditionalExpr+=Condition | 
	 *                 undeterminedloops+=UnDeterminedLoop | 
	 *                 determinedloops+=ForLoop | 
	 *                 (event+=[Event|ID] inputParamsEvent+=InputParam*)
	 *             )? 
	 *             restriction+=RestrictionClause?
	 *         )* 
	 *         restrictionElse+=RestrictionClause? 
	 *         (
	 *             (
	 *                 propertiesElse+=Properties | 
	 *                 expressionsElse+=Expression | 
	 *                 expressionsElse+=BREAK | 
	 *                 expressionsElse+=CONTINUE | 
	 *                 conditionalExprElse+=Condition | 
	 *                 undeterminedloopsElse+=UnDeterminedLoop | 
	 *                 determinedloopsElse+=ForLoop | 
	 *                 (eventElse+=[Event|ID] inputParamsEventElse+=InputParam*)
	 *             )? 
	 *             restrictionElse+=RestrictionClause?
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constructor returns Constructor
	 *
	 * Constraint:
	 *     (
	 *         inputParams+=InputParam* 
	 *         (type='public' | type='internal')? 
	 *         (constructorContractInherance+=[Contract|ID] inputParamsConstructorContractInherance+=InputParam*)? 
	 *         payable='payable'? 
	 *         (
	 *             restrictions+=Restriction | 
	 *             restrictions+=RestrictionGas | 
	 *             restrictions+=Assert | 
	 *             conditions+=Condition | 
	 *             undeterminedLoops+=UnDeterminedLoop | 
	 *             determinedLoops+=ForLoop | 
	 *             attributesInitialization+=Expression
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_Constructor(ISerializationContext context, Constructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Contract
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     (
	 *         name=Identifier 
	 *         superType+=[Element|ID]* 
	 *         (
	 *             localEnumerators+=Enum | 
	 *             localProperties+=Properties | 
	 *             localMappingProperties+=Mapping | 
	 *             structs+=PersonalizedStruct | 
	 *             structUser=User | 
	 *             structCompany=Company | 
	 *             libraries+=[Library|ID]
	 *         )* 
	 *         constructors+=Constructor* 
	 *         modifiers+=Modifier* 
	 *         events+=Event* 
	 *         errors+=Error* 
	 *         clauses+=Clause*
	 *     )
	 * </pre>
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeclarationFunctionAbstractContract returns DeclarationFunctionAbstractContract
	 *
	 * Constraint:
	 *     (
	 *         name=Identifier 
	 *         inputParams+=InputParam* 
	 *         visibility=Visibility 
	 *         (modifier='view' | modifier='payable')? 
	 *         virtual=VIRTUAL? 
	 *         outputParams+=OutputParam?
	 *     )
	 * </pre>
	 */
	protected void sequence_DeclarationFunctionAbstractContract(ISerializationContext context, DeclarationFunctionAbstractContract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeclarationFunctionInterface returns DeclarationFunctionInterface
	 *
	 * Constraint:
	 *     (name=Identifier inputParams+=InputParam* (modifier='view' | modifier='payable')? outputParams+=OutputParam?)
	 * </pre>
	 */
	protected void sequence_DeclarationFunctionInterface(ISerializationContext context, DeclarationFunctionInterface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnDeterminedLoop returns DoWhileLoop
	 *     DoWhileLoop returns DoWhileLoop
	 *
	 * Constraint:
	 *     (
	 *         gasrestriction+=RestrictionGas 
	 *         restriction+=RestrictionClause? 
	 *         (
	 *             (
	 *                 conditions+=Condition | 
	 *                 undeterminedloops+=UnDeterminedLoop | 
	 *                 determinedloops+=ForLoop | 
	 *                 (event+=[Event|ID] inputParams+=InputParam*) | 
	 *                 expressions+=Expression | 
	 *                 expressions+=BREAK | 
	 *                 expressions+=CONTINUE
	 *             )? 
	 *             restriction+=RestrictionClause?
	 *         )* 
	 *         (
	 *             condition=AndExpression | 
	 *             condition=OrExpression | 
	 *             condition=ArithmeticalComparationExpression | 
	 *             condition=ComparationExpression | 
	 *             condition=CallFunctionExpression | 
	 *             condition=BoolValueExpression
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_DoWhileLoop(ISerializationContext context, DoWhileLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attributes returns Enum
	 *     DataType returns Enum
	 *     Enum returns Enum
	 *
	 * Constraint:
	 *     (nameEnumerator=Identifier values+=Identifier*)
	 * </pre>
	 */
	protected void sequence_Enum(ISerializationContext context, org.xtext.smaC.Enum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Error returns Error
	 *
	 * Constraint:
	 *     (name=Identifier inputParams+=InputParam*)
	 * </pre>
	 */
	protected void sequence_Error(ISerializationContext context, org.xtext.smaC.Error semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (name=Identifier inputParams+=InputParam*)
	 * </pre>
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     File returns File
	 *
	 * Constraint:
	 *     (
	 *         version=Version 
	 *         experimentalVersion=ExperimentalVersion? 
	 *         library+=Library* 
	 *         imports+=Import* 
	 *         interfaces+=Interface* 
	 *         abstractContracts+=AbstractContract* 
	 *         contracts+=Contract+
	 *     )
	 * </pre>
	 */
	protected void sequence_File(ISerializationContext context, File semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ForLoop returns ForLoop
	 *
	 * Constraint:
	 *     (
	 *         (((typeCounter='uint' | typeCounter='int') nameCounter=Identifier value=INT) | (typeCounter='char' nameCounter=Identifier valueCounter=CHAR)) 
	 *         condition=ArithmeticalComparationExpression 
	 *         gasrestriction+=RestrictionGas 
	 *         (
	 *             restriction+=RestrictionClause | 
	 *             properties+=Properties | 
	 *             conditions+=Condition | 
	 *             undeterminedloops+=UnDeterminedLoop | 
	 *             determinedloops+=ForLoop | 
	 *             expressions+=Expression | 
	 *             expressions+=BREAK | 
	 *             expressions+=CONTINUE
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_ForLoop(ISerializationContext context, ForLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (name=SyntaxExpression | (alias=Identifier name=SyntaxExpression) | (name=SyntaxExpression alias=Identifier))
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InputParam returns InputParam
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (type=SingularType | type='Company' | type='User' | type=Identifier) 
	 *             array=Array? 
	 *             indexed=INDEXED? 
	 *             storageData=StorageData? 
	 *             (valueInput=Identifier | valueInput=IdentifierDotExpression)
	 *         ) | 
	 *         valueInput=Identifier | 
	 *         valueInput=IdentifierDotExpression | 
	 *         valueInput=MSGVariables | 
	 *         valueInput=BlockVariables | 
	 *         valueInput=TxVariables | 
	 *         valueInput=SyntaxExpression | 
	 *         valueInput=NumberExpression | 
	 *         valueInput=ArithmeticalExpression | 
	 *         valueInput=BoolValueExpression | 
	 *         valueInput=ArithmeticalComparationExpression | 
	 *         valueInput=CoinExpression
	 *     )
	 * </pre>
	 */
	protected void sequence_InputParam(ISerializationContext context, InputParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Interface
	 *     Interface returns Interface
	 *
	 * Constraint:
	 *     (name=Identifier interfaceEvents+=Event* interfaceFunction+=DeclarationFunctionInterface+)
	 * </pre>
	 */
	protected void sequence_Interface(ISerializationContext context, Interface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Library returns Library
	 *
	 * Constraint:
	 *     (name=Identifier structs+=PersonalizedStruct* enums+=Enum* functions+=Clause*)
	 * </pre>
	 */
	protected void sequence_Library(ISerializationContext context, Library semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MappingDeclaration returns MappingDeclaration
	 *     InputParam returns MappingDeclaration
	 *
	 * Constraint:
	 *     (
	 *         type='mapping' 
	 *         key=SingularType 
	 *         (((value=SingularType | value='User' | value='Company' | value=Identifier) array=Array?) | (valueIdentifier=MappingDeclaration array=Array?))
	 *     )
	 * </pre>
	 */
	protected void sequence_MappingDeclaration(ISerializationContext context, MappingDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mapping returns Mapping
	 *
	 * Constraint:
	 *     (
	 *         type=MappingDeclaration 
	 *         array=Array? 
	 *         constant=CONSTANT? 
	 *         visibility=Visibility? 
	 *         storageData=StorageData? 
	 *         nameMapping=Identifier 
	 *         (inicialization=Identifier | inicialization=NumberExpression | inicialization=SyntaxExpression)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Modifier returns Modifier
	 *
	 * Constraint:
	 *     (
	 *         name=Identifier 
	 *         inputParams+=InputParam* 
	 *         (conditionRestricion+=Restriction | conditionRestricion+=RestrictionGas | conditionRestricion+=Assert)* 
	 *         expressionsAssignValueBeforeMark+=AssignExpression? 
	 *         (conditionsBeforeMark+=Condition? expressionsAssignValueBeforeMark+=AssignExpression?)* 
	 *         expressionsAssignValueAfterMark+=AssignExpression? 
	 *         (conditionsAfterMark+=Condition? expressionsAssignValueAfterMark+=AssignExpression?)*
	 *     )
	 * </pre>
	 */
	protected void sequence_Modifier(ISerializationContext context, Modifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OutputParam returns OutputParam
	 *
	 * Constraint:
	 *     (
	 *         ((type=SingularType | type='Company' | type='User' | type=Identifier) array=Array? storageData=StorageData? value=Identifier?) | 
	 *         value=ComparationExpression | 
	 *         value=ArithmeticalComparationExpression | 
	 *         value=MSGVariables | 
	 *         value=IdentifierDotExpression | 
	 *         value=Identifier | 
	 *         value=ArithmeticalExpression
	 *     )
	 * </pre>
	 */
	protected void sequence_OutputParam(ISerializationContext context, OutputParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OverrideModifier returns OverrideModifier
	 *
	 * Constraint:
	 *     inputparamsOverride+=InputParam*
	 * </pre>
	 */
	protected void sequence_OverrideModifier(ISerializationContext context, OverrideModifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PersonalizedStruct returns PersonalizedStruct
	 *
	 * Constraint:
	 *     (name=Identifier properties+=Properties* mapping+=Mapping* structs+=PersonalizedStruct*)
	 * </pre>
	 */
	protected void sequence_PersonalizedStruct(ISerializationContext context, PersonalizedStruct semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Properties returns PropertyAddress
	 *     PropertyAddress returns PropertyAddress
	 *
	 * Constraint:
	 *     (
	 *         type=TypeAddress 
	 *         array=Array? 
	 *         constant=CONSTANT? 
	 *         visibility=Visibility? 
	 *         storageData=StorageData? 
	 *         name=Identifier 
	 *         (
	 *             inicialization=Identifier | 
	 *             inicialization=IdentifierValueExpression | 
	 *             inicialization=ADDRESSEXPRESION | 
	 *             inicialization=MSGSENDER | 
	 *             inicialization=BracketExpression | 
	 *             inicialization=TypeCastingExpression | 
	 *             inicialization=CallFunctionExpression | 
	 *             inicialization=CreateAddressObjectExpression
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_PropertyAddress(ISerializationContext context, PropertyAddress semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Properties returns PropertyBoolean
	 *     PropertyBoolean returns PropertyBoolean
	 *
	 * Constraint:
	 *     (
	 *         type=TypeBool 
	 *         array=Array? 
	 *         constant=CONSTANT? 
	 *         visibility=Visibility? 
	 *         storageData=StorageData? 
	 *         name=Identifier 
	 *         (
	 *             inicialization=Identifier | 
	 *             inicialization=IdentifierValueExpression | 
	 *             inicialization=BoolValueExpression | 
	 *             inicialization=CallFunctionExpression | 
	 *             inicialization=CreateBoolObjectExpression
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_PropertyBoolean(ISerializationContext context, PropertyBoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Properties returns PropertyBytes
	 *     PropertyBytes returns PropertyBytes
	 *
	 * Constraint:
	 *     (
	 *         type=TypeBytes 
	 *         array=Array? 
	 *         constant=CONSTANT? 
	 *         visibility=Visibility? 
	 *         storageData=StorageData? 
	 *         name=Identifier 
	 *         (
	 *             inicialization=HEXEXPRESSION | 
	 *             inicialization=Identifier | 
	 *             inicialization=IdentifierValueExpression | 
	 *             inicialization=ADDRESSEXPRESION | 
	 *             inicialization=AbyExpression | 
	 *             inicialization=TypeCastingExpression | 
	 *             inicialization=CallFunctionExpression | 
	 *             inicialization=CreateByteObjectExpression | 
	 *             inicialization=Sha256Expression
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_PropertyBytes(ISerializationContext context, PropertyBytes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Properties returns PropertyCompany
	 *     PropertyCompany returns PropertyCompany
	 *
	 * Constraint:
	 *     (
	 *         type='Company' 
	 *         array=Array? 
	 *         constant=CONSTANT? 
	 *         visibility=Visibility? 
	 *         storageData=StorageData? 
	 *         name=Identifier 
	 *         (
	 *             inicialization=Identifier | 
	 *             inicialization=IdentifierValueExpression | 
	 *             inicialization=BracketExpression | 
	 *             inicialization=PersonalizedTypeCompanyInicialization | 
	 *             inicialization=NewPersonalizedTypeCompanyInicialization
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_PropertyCompany(ISerializationContext context, PropertyCompany semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Properties returns PropertyFloat
	 *     PropertyFloat returns PropertyFloat
	 *
	 * Constraint:
	 *     (
	 *         type='float' 
	 *         array=Array? 
	 *         constant=CONSTANT? 
	 *         visibility=Visibility? 
	 *         storageData=StorageData? 
	 *         name=Identifier 
	 *         (
	 *             inicialization=NumberExpression | 
	 *             inicialization=Identifier | 
	 *             inicialization=IdentifierDotExpression | 
	 *             inicialization=ArithmeticalExpression | 
	 *             inicialization='now' | 
	 *             inicialization=BracketExpression | 
	 *             inicialization=TypeCastingExpression | 
	 *             inicialization=CallFunctionExpression
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_PropertyFloat(ISerializationContext context, PropertyFloat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Properties returns PropertyIdentifier
	 *     PropertyIdentifier returns PropertyIdentifier
	 *
	 * Constraint:
	 *     (
	 *         (type=Identifier | type=IdentifierValueExpression) 
	 *         array=Array? 
	 *         constant=CONSTANT? 
	 *         visibility=Visibility? 
	 *         storageData=StorageData? 
	 *         name=Identifier 
	 *         (
	 *             inicialization=Identifier | 
	 *             inicialization=IdentifierValueExpression | 
	 *             inicialization=StructInicializationKeyExpression | 
	 *             inicialization=BracketExpression
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_PropertyIdentifier(ISerializationContext context, PropertyIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Properties returns PropertyInteger
	 *     PropertyInteger returns PropertyInteger
	 *
	 * Constraint:
	 *     (
	 *         type=TypeInt 
	 *         array=Array? 
	 *         constant=CONSTANT? 
	 *         visibility=Visibility? 
	 *         storageData=StorageData? 
	 *         name=Identifier 
	 *         (
	 *             inicialization=NumberExpression | 
	 *             inicialization=Identifier | 
	 *             inicialization=IdentifierDotExpression | 
	 *             inicialization=ArithmeticalExpression | 
	 *             inicialization='now' | 
	 *             inicialization=BracketExpression | 
	 *             inicialization=TypeCastingExpression | 
	 *             inicialization=CallFunctionExpression | 
	 *             inicialization=CreateIntObjectExpression
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_PropertyInteger(ISerializationContext context, PropertyInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Properties returns PropertyString
	 *     PropertyString returns PropertyString
	 *
	 * Constraint:
	 *     (
	 *         type=TypeString 
	 *         array=Array? 
	 *         constant=CONSTANT? 
	 *         visibility=Visibility? 
	 *         storageData=StorageData? 
	 *         name=Identifier 
	 *         (
	 *             inicialization=SyntaxExpression | 
	 *             inicialization=Identifier | 
	 *             inicialization=IdentifierDotExpression | 
	 *             inicialization=BracketExpression | 
	 *             inicialization=CallFunctionExpression | 
	 *             inicialization=CreateStringObjectExpression
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_PropertyString(ISerializationContext context, PropertyString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Properties returns PropertyUInteger
	 *     PropertyUInteger returns PropertyUInteger
	 *
	 * Constraint:
	 *     (
	 *         type=TypeUint 
	 *         array=Array? 
	 *         constant=CONSTANT? 
	 *         visibility=Visibility? 
	 *         storageData=StorageData? 
	 *         name=Identifier 
	 *         (
	 *             inicialization=NumberExpression | 
	 *             inicialization=Identifier | 
	 *             inicialization=IdentifierValueExpression | 
	 *             inicialization=ArithmeticalExpression | 
	 *             inicialization='now' | 
	 *             inicialization=BracketExpression | 
	 *             inicialization=BCKTIMESTAMP | 
	 *             inicialization=TypeCastingExpression | 
	 *             inicialization=CallFunctionExpression | 
	 *             inicialization=CreateUintObjectExpression | 
	 *             inicialization=ArrayExpression
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_PropertyUInteger(ISerializationContext context, PropertyUInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Properties returns PropertyUser
	 *     PropertyUser returns PropertyUser
	 *
	 * Constraint:
	 *     (
	 *         type='User' 
	 *         array=Array? 
	 *         constant=CONSTANT? 
	 *         visibility=Visibility? 
	 *         storageData=StorageData? 
	 *         name=Identifier 
	 *         (
	 *             inicialization=Identifier | 
	 *             inicialization=IdentifierValueExpression | 
	 *             inicialization=BracketExpression | 
	 *             inicialization=PersonalizedTypeUserInicialization | 
	 *             inicialization=NewPersonalizedTypeUserInicialization
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_PropertyUser(ISerializationContext context, PropertyUser semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RestrictionClause returns RestrictionGas
	 *     RestrictionGas returns RestrictionGas
	 *
	 * Constraint:
	 *     (
	 *         (expr1=Identifier | expr1=NumberExpression | expr1=BracketExpression | expr1=IdentifierDotExpression | expr1=MSGVariables) 
	 *         operator=ComparationOperator 
	 *         amount=NumberExpression 
	 *         typeCoin=Coin 
	 *         message=SyntaxExpression?
	 *     )
	 * </pre>
	 */
	protected void sequence_RestrictionGas(ISerializationContext context, RestrictionGas semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RestrictionClause returns Restriction
	 *     Restriction returns Restriction
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             expr1=SyntaxExpression | 
	 *             expr1=Identifier | 
	 *             expr1=NumberExpression | 
	 *             expr1=ArithmeticalExpression | 
	 *             expr1=BracketExpression | 
	 *             expr1='now' | 
	 *             expr1=IdentifierDotExpression | 
	 *             expr1=MSGVariables | 
	 *             expr1=TypeCastingExpression | 
	 *             expr1=BCKTIMESTAMP | 
	 *             expr1=CallFunctionExpression | 
	 *             expr1=BoolValueExpression | 
	 *             expr1=BracketExpression | 
	 *             expr1=IdentifierDotExpression | 
	 *             expr1=SyntaxExpression | 
	 *             expr1=Identifier | 
	 *             expr1=NumberExpression | 
	 *             expr1=ArithmeticalExpression | 
	 *             expr1=MSGVariables | 
	 *             expr1=BlockVariables | 
	 *             expr1='now' | 
	 *             expr1=TypeCastingExpression | 
	 *             expr1=CallFunctionExpression
	 *         ) 
	 *         (
	 *             operator=ComparationOperator 
	 *             (
	 *                 expr2=SyntaxExpression | 
	 *                 expr2=Identifier | 
	 *                 expr2=NumberExpression | 
	 *                 expr2=IdentifierDotExpression | 
	 *                 expr2=ArithmeticalExpression | 
	 *                 expr2=MSGVariables | 
	 *                 expr2='now' | 
	 *                 expr2=BracketExpression | 
	 *                 expr2=TypeCastingExpression | 
	 *                 expr2=CallFunctionExpression | 
	 *                 expr2=BoolValueExpression
	 *             )
	 *         )? 
	 *         message=SyntaxExpression?
	 *     )
	 * </pre>
	 */
	protected void sequence_Restriction(ISerializationContext context, Restriction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     User returns User
	 *
	 * Constraint:
	 *     (
	 *         name='User' 
	 *         nameAttributeAddress=Identifier 
	 *         nameAttributeUser=Identifier 
	 *         nameAttributeSurnameUser=Identifier 
	 *         emailAttributeUser=Identifier 
	 *         properties+=Properties* 
	 *         mapping+=Mapping* 
	 *         structs+=PersonalizedStruct*
	 *     )
	 * </pre>
	 */
	protected void sequence_User(ISerializationContext context, User semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Version returns Version
	 *
	 * Constraint:
	 *     ((symbol='^' | symbol='&gt;' | symbol='&gt;=') numberVersion=NUMVERSION ((symbolComparation='&lt;' | symbolComparation='&lt;=') numberVersion2=NUMVERSION)?)
	 * </pre>
	 */
	protected void sequence_Version(ISerializationContext context, Version semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnDeterminedLoop returns WhileLoop
	 *     WhileLoop returns WhileLoop
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             condition=AndExpression | 
	 *             condition=OrExpression | 
	 *             condition=ArithmeticalComparationExpression | 
	 *             condition=ComparationExpression | 
	 *             condition=IdentifierValueExpression | 
	 *             condition=CallFunctionExpression | 
	 *             condition=BoolValueExpression
	 *         ) 
	 *         gasrestriction+=RestrictionGas 
	 *         (
	 *             (
	 *                 restriction+=RestrictionClause | 
	 *                 properties+=Properties | 
	 *                 conditions+=Condition | 
	 *                 undeterminedloops+=UnDeterminedLoop | 
	 *                 determinedloops+=ForLoop | 
	 *                 expressions+=Expression | 
	 *                 expressions+=BREAK | 
	 *                 expressions+=CONTINUE
	 *             )? 
	 *             (event+=[Event|ID] inputParams+=InputParam*)?
	 *         )+
	 *     )
	 * </pre>
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
