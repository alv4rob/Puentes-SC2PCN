/*
 * generated by Xtext 2.34.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.IGrammarAccess;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AbstractElementAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AlternativeAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.GroupAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.TokenAlias;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynNavigable;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynTransition;
import org.eclipse.xtext.serializer.sequencer.AbstractSyntacticSequencer;
import org.xtext.services.SmaCGrammarAccess;

@SuppressWarnings("all")
public class SmaCSyntacticSequencer extends AbstractSyntacticSequencer {

	protected SmaCGrammarAccess grammarAccess;
	protected AbstractElementAlias match_AbstractContract_COMMATerminalRuleCall_2_1_1_q;
	protected AbstractElementAlias match_AbstractContract_EOLINETerminalRuleCall_10_q;
	protected AbstractElementAlias match_AbstractContract_EOLINETerminalRuleCall_4_q;
	protected AbstractElementAlias match_AbstractContract_IsKeyword_2_0_q;
	protected AbstractElementAlias match_Assert_EOLINETerminalRuleCall_5_q;
	protected AbstractElementAlias match_Assert_LogicalUnaryOperatorParserRuleCall_2_0_0_0_q;
	protected AbstractElementAlias match_Assert_LogicalUnaryOperatorParserRuleCall_2_0_1_1_0_q;
	protected AbstractElementAlias match_Clause_EOLINETerminalRuleCall_13_q;
	protected AbstractElementAlias match_Clause_EOLINETerminalRuleCall_14_6_1_q;
	protected AbstractElementAlias match_Clause_EOLINETerminalRuleCall_14_8_6_q;
	protected AbstractElementAlias match_Clause_EOLINETerminalRuleCall_16_q;
	protected AbstractElementAlias match_Clause___OPENPARENTHESISTerminalRuleCall_14_8_2_CLOSEPARENTHESISTerminalRuleCall_14_8_4_SEMICOLONTerminalRuleCall_14_8_5_EOLINETerminalRuleCall_14_8_6_q_EMITTerminalRuleCall_14_8_0__q;
	protected AbstractElementAlias match_Clause___OPENPARENTHESISTerminalRuleCall_8_1_0_CLOSEPARENTHESISTerminalRuleCall_8_1_2__q;
	protected AbstractElementAlias match_Clause___RETURNSTerminalRuleCall_11_0_OPENPARENTHESISTerminalRuleCall_11_1_CLOSEPARENTHESISTerminalRuleCall_11_3__q;
	protected AbstractElementAlias match_Company_EOLINETerminalRuleCall_12_q;
	protected AbstractElementAlias match_Company_EOLINETerminalRuleCall_16_q;
	protected AbstractElementAlias match_Company_EOLINETerminalRuleCall_20_q;
	protected AbstractElementAlias match_Company_EOLINETerminalRuleCall_25_q;
	protected AbstractElementAlias match_Company_EOLINETerminalRuleCall_4_q;
	protected AbstractElementAlias match_Company_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_Condition_EOLINETerminalRuleCall_5_q;
	protected AbstractElementAlias match_Condition_EOLINETerminalRuleCall_6_6_6_q;
	protected AbstractElementAlias match_Condition_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_Condition_EOLINETerminalRuleCall_9_2_q;
	protected AbstractElementAlias match_Condition_EOLINETerminalRuleCall_9_3_6_6_q;
	protected AbstractElementAlias match_Condition_EOLINETerminalRuleCall_9_5_q;
	protected AbstractElementAlias match_Condition___ELSETerminalRuleCall_9_0_OPENKEYTerminalRuleCall_9_1_EOLINETerminalRuleCall_9_2_q_CLOSEKEYTerminalRuleCall_9_4_EOLINETerminalRuleCall_9_5_q__q;
	protected AbstractElementAlias match_Constructor_EOLINETerminalRuleCall_11_q;
	protected AbstractElementAlias match_Constructor_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_Constructor_SEMICOLONTerminalRuleCall_9_4_1_q;
	protected AbstractElementAlias match_Contract_AsteriskKeyword_5_6_3_3_or_BracketExpressionParserRuleCall_5_6_3_2_or_IdentifierParserRuleCall_5_6_3_0_or_IdentifierValueExpressionParserRuleCall_5_6_3_1_or_SingularTypeParserRuleCall_5_6_3_4;
	protected AbstractElementAlias match_Contract_COMMATerminalRuleCall_2_1_1_q;
	protected AbstractElementAlias match_Contract_EOLINETerminalRuleCall_12_q;
	protected AbstractElementAlias match_Contract_EOLINETerminalRuleCall_4_q;
	protected AbstractElementAlias match_Contract_EOLINETerminalRuleCall_5_6_5_q;
	protected AbstractElementAlias match_Contract_IsKeyword_2_0_q;
	protected AbstractElementAlias match_Contract___ForKeyword_5_6_2___AsteriskKeyword_5_6_3_3_or_BracketExpressionParserRuleCall_5_6_3_2_or_IdentifierParserRuleCall_5_6_3_0_or_IdentifierValueExpressionParserRuleCall_5_6_3_1_or_SingularTypeParserRuleCall_5_6_3_4___SEMICOLONTerminalRuleCall_5_6_4_EOLINETerminalRuleCall_5_6_5_q_UsingKeyword_5_6_0__q;
	protected AbstractElementAlias match_DeclarationFunctionAbstractContract_EOLINETerminalRuleCall_10_q;
	protected AbstractElementAlias match_DeclarationFunctionInterface_EOLINETerminalRuleCall_9_q;
	protected AbstractElementAlias match_DeclarationFunctionInterface_ExternalKeyword_5_q;
	protected AbstractElementAlias match_DoWhileLoop_EOLINETerminalRuleCall_10_q;
	protected AbstractElementAlias match_DoWhileLoop_EOLINETerminalRuleCall_2_q;
	protected AbstractElementAlias match_Enum_COMMATerminalRuleCall_3_1_q;
	protected AbstractElementAlias match_Enum_EOLINETerminalRuleCall_5_q;
	protected AbstractElementAlias match_Error_EOLINETerminalRuleCall_6_q;
	protected AbstractElementAlias match_Event_EOLINETerminalRuleCall_6_q;
	protected AbstractElementAlias match_ForLoop_DecrementLoopExpressionParserRuleCall_6_1_or_IncrementLoopExpressionParserRuleCall_6_0;
	protected AbstractElementAlias match_ForLoop_EOLINETerminalRuleCall_11_5_1_q;
	protected AbstractElementAlias match_ForLoop_EOLINETerminalRuleCall_13_q;
	protected AbstractElementAlias match_ForLoop_EOLINETerminalRuleCall_9_q;
	protected AbstractElementAlias match_Import_EOLINETerminalRuleCall_0_3_q;
	protected AbstractElementAlias match_Import_EOLINETerminalRuleCall_1_7_q;
	protected AbstractElementAlias match_Import_EOLINETerminalRuleCall_2_5_q;
	protected AbstractElementAlias match_InputParam_COMMATerminalRuleCall_1_q;
	protected AbstractElementAlias match_Interface_EOLINETerminalRuleCall_3_q;
	protected AbstractElementAlias match_Interface_EOLINETerminalRuleCall_7_q;
	protected AbstractElementAlias match_Mapping_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_Modifier_EOLINETerminalRuleCall_12_q;
	protected AbstractElementAlias match_Modifier_EOLINETerminalRuleCall_6_q;
	protected AbstractElementAlias match_Modifier_SEMICOLONTerminalRuleCall_10_0_1_q;
	protected AbstractElementAlias match_Modifier_SEMICOLONTerminalRuleCall_8_0_1_q;
	protected AbstractElementAlias match_OutputParam_COMMATerminalRuleCall_1_q;
	protected AbstractElementAlias match_PersonalizedStruct_EOLINETerminalRuleCall_3_q;
	protected AbstractElementAlias match_PersonalizedStruct_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_PropertyAddress_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_PropertyBoolean_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_PropertyBytes_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_PropertyCompany_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_PropertyFloat_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_PropertyIdentifier_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_PropertyInteger_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_PropertyString_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_PropertyUInteger_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_PropertyUser_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_RestrictionGas_EOLINETerminalRuleCall_9_q;
	protected AbstractElementAlias match_Restriction_EOLINETerminalRuleCall_5_q;
	protected AbstractElementAlias match_Restriction_LogicalUnaryOperatorParserRuleCall_2_0_0_0_0_q;
	protected AbstractElementAlias match_Restriction_LogicalUnaryOperatorParserRuleCall_2_0_0_1_1_0_q;
	protected AbstractElementAlias match_User_EOLINETerminalRuleCall_12_q;
	protected AbstractElementAlias match_User_EOLINETerminalRuleCall_16_q;
	protected AbstractElementAlias match_User_EOLINETerminalRuleCall_20_q;
	protected AbstractElementAlias match_User_EOLINETerminalRuleCall_25_q;
	protected AbstractElementAlias match_User_EOLINETerminalRuleCall_4_q;
	protected AbstractElementAlias match_User_EOLINETerminalRuleCall_8_q;
	protected AbstractElementAlias match_Version_EOLINETerminalRuleCall_5_q;
	protected AbstractElementAlias match_WhileLoop_EOLINETerminalRuleCall_5_q;
	protected AbstractElementAlias match_WhileLoop_EOLINETerminalRuleCall_9_q;
	
	@Inject
	protected void init(IGrammarAccess access) {
		grammarAccess = (SmaCGrammarAccess) access;
		init0();
		init1();
	}
	
	private void init0() {
		match_AbstractContract_COMMATerminalRuleCall_2_1_1_q = new TokenAlias(false, true, grammarAccess.getAbstractContractAccess().getCOMMATerminalRuleCall_2_1_1());
		match_AbstractContract_EOLINETerminalRuleCall_10_q = new TokenAlias(false, true, grammarAccess.getAbstractContractAccess().getEOLINETerminalRuleCall_10());
		match_AbstractContract_EOLINETerminalRuleCall_4_q = new TokenAlias(false, true, grammarAccess.getAbstractContractAccess().getEOLINETerminalRuleCall_4());
		match_AbstractContract_IsKeyword_2_0_q = new TokenAlias(false, true, grammarAccess.getAbstractContractAccess().getIsKeyword_2_0());
		match_Assert_EOLINETerminalRuleCall_5_q = new TokenAlias(false, true, grammarAccess.getAssertAccess().getEOLINETerminalRuleCall_5());
		match_Assert_LogicalUnaryOperatorParserRuleCall_2_0_0_0_q = new TokenAlias(false, true, grammarAccess.getAssertAccess().getLogicalUnaryOperatorParserRuleCall_2_0_0_0());
		match_Assert_LogicalUnaryOperatorParserRuleCall_2_0_1_1_0_q = new TokenAlias(false, true, grammarAccess.getAssertAccess().getLogicalUnaryOperatorParserRuleCall_2_0_1_1_0());
		match_Clause_EOLINETerminalRuleCall_13_q = new TokenAlias(false, true, grammarAccess.getClauseAccess().getEOLINETerminalRuleCall_13());
		match_Clause_EOLINETerminalRuleCall_14_6_1_q = new TokenAlias(false, true, grammarAccess.getClauseAccess().getEOLINETerminalRuleCall_14_6_1());
		match_Clause_EOLINETerminalRuleCall_14_8_6_q = new TokenAlias(false, true, grammarAccess.getClauseAccess().getEOLINETerminalRuleCall_14_8_6());
		match_Clause_EOLINETerminalRuleCall_16_q = new TokenAlias(false, true, grammarAccess.getClauseAccess().getEOLINETerminalRuleCall_16());
		match_Clause___OPENPARENTHESISTerminalRuleCall_14_8_2_CLOSEPARENTHESISTerminalRuleCall_14_8_4_SEMICOLONTerminalRuleCall_14_8_5_EOLINETerminalRuleCall_14_8_6_q_EMITTerminalRuleCall_14_8_0__q = new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getClauseAccess().getOPENPARENTHESISTerminalRuleCall_14_8_2()), new TokenAlias(false, false, grammarAccess.getClauseAccess().getCLOSEPARENTHESISTerminalRuleCall_14_8_4()), new TokenAlias(false, false, grammarAccess.getClauseAccess().getSEMICOLONTerminalRuleCall_14_8_5()), new TokenAlias(false, true, grammarAccess.getClauseAccess().getEOLINETerminalRuleCall_14_8_6()), new TokenAlias(false, false, grammarAccess.getClauseAccess().getEMITTerminalRuleCall_14_8_0()));
		match_Clause___OPENPARENTHESISTerminalRuleCall_8_1_0_CLOSEPARENTHESISTerminalRuleCall_8_1_2__q = new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getClauseAccess().getOPENPARENTHESISTerminalRuleCall_8_1_0()), new TokenAlias(false, false, grammarAccess.getClauseAccess().getCLOSEPARENTHESISTerminalRuleCall_8_1_2()));
		match_Clause___RETURNSTerminalRuleCall_11_0_OPENPARENTHESISTerminalRuleCall_11_1_CLOSEPARENTHESISTerminalRuleCall_11_3__q = new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getClauseAccess().getRETURNSTerminalRuleCall_11_0()), new TokenAlias(false, false, grammarAccess.getClauseAccess().getOPENPARENTHESISTerminalRuleCall_11_1()), new TokenAlias(false, false, grammarAccess.getClauseAccess().getCLOSEPARENTHESISTerminalRuleCall_11_3()));
		match_Company_EOLINETerminalRuleCall_12_q = new TokenAlias(false, true, grammarAccess.getCompanyAccess().getEOLINETerminalRuleCall_12());
		match_Company_EOLINETerminalRuleCall_16_q = new TokenAlias(false, true, grammarAccess.getCompanyAccess().getEOLINETerminalRuleCall_16());
		match_Company_EOLINETerminalRuleCall_20_q = new TokenAlias(false, true, grammarAccess.getCompanyAccess().getEOLINETerminalRuleCall_20());
		match_Company_EOLINETerminalRuleCall_25_q = new TokenAlias(false, true, grammarAccess.getCompanyAccess().getEOLINETerminalRuleCall_25());
		match_Company_EOLINETerminalRuleCall_4_q = new TokenAlias(false, true, grammarAccess.getCompanyAccess().getEOLINETerminalRuleCall_4());
		match_Company_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getCompanyAccess().getEOLINETerminalRuleCall_8());
		match_Condition_EOLINETerminalRuleCall_5_q = new TokenAlias(false, true, grammarAccess.getConditionAccess().getEOLINETerminalRuleCall_5());
		match_Condition_EOLINETerminalRuleCall_6_6_6_q = new TokenAlias(false, true, grammarAccess.getConditionAccess().getEOLINETerminalRuleCall_6_6_6());
		match_Condition_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getConditionAccess().getEOLINETerminalRuleCall_8());
		match_Condition_EOLINETerminalRuleCall_9_2_q = new TokenAlias(false, true, grammarAccess.getConditionAccess().getEOLINETerminalRuleCall_9_2());
		match_Condition_EOLINETerminalRuleCall_9_3_6_6_q = new TokenAlias(false, true, grammarAccess.getConditionAccess().getEOLINETerminalRuleCall_9_3_6_6());
		match_Condition_EOLINETerminalRuleCall_9_5_q = new TokenAlias(false, true, grammarAccess.getConditionAccess().getEOLINETerminalRuleCall_9_5());
		match_Condition___ELSETerminalRuleCall_9_0_OPENKEYTerminalRuleCall_9_1_EOLINETerminalRuleCall_9_2_q_CLOSEKEYTerminalRuleCall_9_4_EOLINETerminalRuleCall_9_5_q__q = new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getConditionAccess().getELSETerminalRuleCall_9_0()), new TokenAlias(false, false, grammarAccess.getConditionAccess().getOPENKEYTerminalRuleCall_9_1()), new TokenAlias(false, true, grammarAccess.getConditionAccess().getEOLINETerminalRuleCall_9_2()), new TokenAlias(false, false, grammarAccess.getConditionAccess().getCLOSEKEYTerminalRuleCall_9_4()), new TokenAlias(false, true, grammarAccess.getConditionAccess().getEOLINETerminalRuleCall_9_5()));
		match_Constructor_EOLINETerminalRuleCall_11_q = new TokenAlias(false, true, grammarAccess.getConstructorAccess().getEOLINETerminalRuleCall_11());
		match_Constructor_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getConstructorAccess().getEOLINETerminalRuleCall_8());
		match_Constructor_SEMICOLONTerminalRuleCall_9_4_1_q = new TokenAlias(false, true, grammarAccess.getConstructorAccess().getSEMICOLONTerminalRuleCall_9_4_1());
		match_Contract_AsteriskKeyword_5_6_3_3_or_BracketExpressionParserRuleCall_5_6_3_2_or_IdentifierParserRuleCall_5_6_3_0_or_IdentifierValueExpressionParserRuleCall_5_6_3_1_or_SingularTypeParserRuleCall_5_6_3_4 = new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getContractAccess().getAsteriskKeyword_5_6_3_3()), new TokenAlias(false, false, grammarAccess.getContractAccess().getBracketExpressionParserRuleCall_5_6_3_2()), new TokenAlias(false, false, grammarAccess.getContractAccess().getIdentifierParserRuleCall_5_6_3_0()), new TokenAlias(false, false, grammarAccess.getContractAccess().getIdentifierValueExpressionParserRuleCall_5_6_3_1()), new TokenAlias(false, false, grammarAccess.getContractAccess().getSingularTypeParserRuleCall_5_6_3_4()));
		match_Contract_COMMATerminalRuleCall_2_1_1_q = new TokenAlias(false, true, grammarAccess.getContractAccess().getCOMMATerminalRuleCall_2_1_1());
		match_Contract_EOLINETerminalRuleCall_12_q = new TokenAlias(false, true, grammarAccess.getContractAccess().getEOLINETerminalRuleCall_12());
		match_Contract_EOLINETerminalRuleCall_4_q = new TokenAlias(false, true, grammarAccess.getContractAccess().getEOLINETerminalRuleCall_4());
		match_Contract_EOLINETerminalRuleCall_5_6_5_q = new TokenAlias(false, true, grammarAccess.getContractAccess().getEOLINETerminalRuleCall_5_6_5());
		match_Contract_IsKeyword_2_0_q = new TokenAlias(false, true, grammarAccess.getContractAccess().getIsKeyword_2_0());
		match_Contract___ForKeyword_5_6_2___AsteriskKeyword_5_6_3_3_or_BracketExpressionParserRuleCall_5_6_3_2_or_IdentifierParserRuleCall_5_6_3_0_or_IdentifierValueExpressionParserRuleCall_5_6_3_1_or_SingularTypeParserRuleCall_5_6_3_4___SEMICOLONTerminalRuleCall_5_6_4_EOLINETerminalRuleCall_5_6_5_q_UsingKeyword_5_6_0__q = new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getContractAccess().getForKeyword_5_6_2()), new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getContractAccess().getAsteriskKeyword_5_6_3_3()), new TokenAlias(false, false, grammarAccess.getContractAccess().getBracketExpressionParserRuleCall_5_6_3_2()), new TokenAlias(false, false, grammarAccess.getContractAccess().getIdentifierParserRuleCall_5_6_3_0()), new TokenAlias(false, false, grammarAccess.getContractAccess().getIdentifierValueExpressionParserRuleCall_5_6_3_1()), new TokenAlias(false, false, grammarAccess.getContractAccess().getSingularTypeParserRuleCall_5_6_3_4())), new TokenAlias(false, false, grammarAccess.getContractAccess().getSEMICOLONTerminalRuleCall_5_6_4()), new TokenAlias(false, true, grammarAccess.getContractAccess().getEOLINETerminalRuleCall_5_6_5()), new TokenAlias(false, false, grammarAccess.getContractAccess().getUsingKeyword_5_6_0()));
		match_DeclarationFunctionAbstractContract_EOLINETerminalRuleCall_10_q = new TokenAlias(false, true, grammarAccess.getDeclarationFunctionAbstractContractAccess().getEOLINETerminalRuleCall_10());
		match_DeclarationFunctionInterface_EOLINETerminalRuleCall_9_q = new TokenAlias(false, true, grammarAccess.getDeclarationFunctionInterfaceAccess().getEOLINETerminalRuleCall_9());
		match_DeclarationFunctionInterface_ExternalKeyword_5_q = new TokenAlias(false, true, grammarAccess.getDeclarationFunctionInterfaceAccess().getExternalKeyword_5());
		match_DoWhileLoop_EOLINETerminalRuleCall_10_q = new TokenAlias(false, true, grammarAccess.getDoWhileLoopAccess().getEOLINETerminalRuleCall_10());
		match_DoWhileLoop_EOLINETerminalRuleCall_2_q = new TokenAlias(false, true, grammarAccess.getDoWhileLoopAccess().getEOLINETerminalRuleCall_2());
		match_Enum_COMMATerminalRuleCall_3_1_q = new TokenAlias(false, true, grammarAccess.getEnumAccess().getCOMMATerminalRuleCall_3_1());
		match_Enum_EOLINETerminalRuleCall_5_q = new TokenAlias(false, true, grammarAccess.getEnumAccess().getEOLINETerminalRuleCall_5());
		match_Error_EOLINETerminalRuleCall_6_q = new TokenAlias(false, true, grammarAccess.getErrorAccess().getEOLINETerminalRuleCall_6());
		match_Event_EOLINETerminalRuleCall_6_q = new TokenAlias(false, true, grammarAccess.getEventAccess().getEOLINETerminalRuleCall_6());
		match_ForLoop_DecrementLoopExpressionParserRuleCall_6_1_or_IncrementLoopExpressionParserRuleCall_6_0 = new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getForLoopAccess().getDecrementLoopExpressionParserRuleCall_6_1()), new TokenAlias(false, false, grammarAccess.getForLoopAccess().getIncrementLoopExpressionParserRuleCall_6_0()));
		match_ForLoop_EOLINETerminalRuleCall_11_5_1_q = new TokenAlias(false, true, grammarAccess.getForLoopAccess().getEOLINETerminalRuleCall_11_5_1());
		match_ForLoop_EOLINETerminalRuleCall_13_q = new TokenAlias(false, true, grammarAccess.getForLoopAccess().getEOLINETerminalRuleCall_13());
		match_ForLoop_EOLINETerminalRuleCall_9_q = new TokenAlias(false, true, grammarAccess.getForLoopAccess().getEOLINETerminalRuleCall_9());
		match_Import_EOLINETerminalRuleCall_0_3_q = new TokenAlias(false, true, grammarAccess.getImportAccess().getEOLINETerminalRuleCall_0_3());
		match_Import_EOLINETerminalRuleCall_1_7_q = new TokenAlias(false, true, grammarAccess.getImportAccess().getEOLINETerminalRuleCall_1_7());
		match_Import_EOLINETerminalRuleCall_2_5_q = new TokenAlias(false, true, grammarAccess.getImportAccess().getEOLINETerminalRuleCall_2_5());
		match_InputParam_COMMATerminalRuleCall_1_q = new TokenAlias(false, true, grammarAccess.getInputParamAccess().getCOMMATerminalRuleCall_1());
		match_Interface_EOLINETerminalRuleCall_3_q = new TokenAlias(false, true, grammarAccess.getInterfaceAccess().getEOLINETerminalRuleCall_3());
		match_Interface_EOLINETerminalRuleCall_7_q = new TokenAlias(false, true, grammarAccess.getInterfaceAccess().getEOLINETerminalRuleCall_7());
		match_Mapping_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getMappingAccess().getEOLINETerminalRuleCall_8());
		match_Modifier_EOLINETerminalRuleCall_12_q = new TokenAlias(false, true, grammarAccess.getModifierAccess().getEOLINETerminalRuleCall_12());
		match_Modifier_EOLINETerminalRuleCall_6_q = new TokenAlias(false, true, grammarAccess.getModifierAccess().getEOLINETerminalRuleCall_6());
		match_Modifier_SEMICOLONTerminalRuleCall_10_0_1_q = new TokenAlias(false, true, grammarAccess.getModifierAccess().getSEMICOLONTerminalRuleCall_10_0_1());
	}
	
	private void init1() {
		match_Modifier_SEMICOLONTerminalRuleCall_8_0_1_q = new TokenAlias(false, true, grammarAccess.getModifierAccess().getSEMICOLONTerminalRuleCall_8_0_1());
		match_OutputParam_COMMATerminalRuleCall_1_q = new TokenAlias(false, true, grammarAccess.getOutputParamAccess().getCOMMATerminalRuleCall_1());
		match_PersonalizedStruct_EOLINETerminalRuleCall_3_q = new TokenAlias(false, true, grammarAccess.getPersonalizedStructAccess().getEOLINETerminalRuleCall_3());
		match_PersonalizedStruct_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getPersonalizedStructAccess().getEOLINETerminalRuleCall_8());
		match_PropertyAddress_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getPropertyAddressAccess().getEOLINETerminalRuleCall_8());
		match_PropertyBoolean_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getPropertyBooleanAccess().getEOLINETerminalRuleCall_8());
		match_PropertyBytes_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getPropertyBytesAccess().getEOLINETerminalRuleCall_8());
		match_PropertyCompany_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getPropertyCompanyAccess().getEOLINETerminalRuleCall_8());
		match_PropertyFloat_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getPropertyFloatAccess().getEOLINETerminalRuleCall_8());
		match_PropertyIdentifier_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getPropertyIdentifierAccess().getEOLINETerminalRuleCall_8());
		match_PropertyInteger_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getPropertyIntegerAccess().getEOLINETerminalRuleCall_8());
		match_PropertyString_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getPropertyStringAccess().getEOLINETerminalRuleCall_8());
		match_PropertyUInteger_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getPropertyUIntegerAccess().getEOLINETerminalRuleCall_8());
		match_PropertyUser_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getPropertyUserAccess().getEOLINETerminalRuleCall_8());
		match_RestrictionGas_EOLINETerminalRuleCall_9_q = new TokenAlias(false, true, grammarAccess.getRestrictionGasAccess().getEOLINETerminalRuleCall_9());
		match_Restriction_EOLINETerminalRuleCall_5_q = new TokenAlias(false, true, grammarAccess.getRestrictionAccess().getEOLINETerminalRuleCall_5());
		match_Restriction_LogicalUnaryOperatorParserRuleCall_2_0_0_0_0_q = new TokenAlias(false, true, grammarAccess.getRestrictionAccess().getLogicalUnaryOperatorParserRuleCall_2_0_0_0_0());
		match_Restriction_LogicalUnaryOperatorParserRuleCall_2_0_0_1_1_0_q = new TokenAlias(false, true, grammarAccess.getRestrictionAccess().getLogicalUnaryOperatorParserRuleCall_2_0_0_1_1_0());
		match_User_EOLINETerminalRuleCall_12_q = new TokenAlias(false, true, grammarAccess.getUserAccess().getEOLINETerminalRuleCall_12());
		match_User_EOLINETerminalRuleCall_16_q = new TokenAlias(false, true, grammarAccess.getUserAccess().getEOLINETerminalRuleCall_16());
		match_User_EOLINETerminalRuleCall_20_q = new TokenAlias(false, true, grammarAccess.getUserAccess().getEOLINETerminalRuleCall_20());
		match_User_EOLINETerminalRuleCall_25_q = new TokenAlias(false, true, grammarAccess.getUserAccess().getEOLINETerminalRuleCall_25());
		match_User_EOLINETerminalRuleCall_4_q = new TokenAlias(false, true, grammarAccess.getUserAccess().getEOLINETerminalRuleCall_4());
		match_User_EOLINETerminalRuleCall_8_q = new TokenAlias(false, true, grammarAccess.getUserAccess().getEOLINETerminalRuleCall_8());
		match_Version_EOLINETerminalRuleCall_5_q = new TokenAlias(false, true, grammarAccess.getVersionAccess().getEOLINETerminalRuleCall_5());
		match_WhileLoop_EOLINETerminalRuleCall_5_q = new TokenAlias(false, true, grammarAccess.getWhileLoopAccess().getEOLINETerminalRuleCall_5());
		match_WhileLoop_EOLINETerminalRuleCall_9_q = new TokenAlias(false, true, grammarAccess.getWhileLoopAccess().getEOLINETerminalRuleCall_9());
	}
	
	@Override
	protected String getUnassignedRuleCallToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (ruleCall.getRule() == grammarAccess.getBracketExpressionRule())
			return getBracketExpressionToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCLOSEKEYRule())
			return getCLOSEKEYToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCLOSEPARENTHESISRule())
			return getCLOSEPARENTHESISToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCOMMARule())
			return getCOMMAToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getDecrementLoopExpressionRule())
			return getDecrementLoopExpressionToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getELSERule())
			return getELSEToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getEMITRule())
			return getEMITToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getEOLINERule())
			return getEOLINEToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getIDRule())
			return getIDToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getIFRule())
			return getIFToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getIdentifierRule())
			return getIdentifierToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getIdentifierValueExpressionRule())
			return getIdentifierValueExpressionToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getIncrementLoopExpressionRule())
			return getIncrementLoopExpressionToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getLogicalUnaryOperatorRule())
			return getLogicalUnaryOperatorToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getOPENKEYRule())
			return getOPENKEYToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getOPENPARENTHESISRule())
			return getOPENPARENTHESISToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getRETURNSRule())
			return getRETURNSToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getSEMICOLONRule())
			return getSEMICOLONToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getSingularTypeRule())
			return getSingularTypeToken(semanticObject, ruleCall, node);
		return "";
	}
	
	/**
	 * BracketExpression returns ecore::EString:
	 * 	Identifier ('[' (Identifier|Identifier '[' (Identifier|INT|BOOLVALUE|ADDRESSEXPRESION|HexadecimalExpression) ']'|IdentifierValueExpression|INT|BOOLVALUE|MSGSENDER|HEXEXPRESSION|ADDRESSEXPRESION) ']')+ (DOT Identifier)*
	 * ;
	 */
	protected String getBracketExpressionToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "[ ]";
	}
	
	/**
	 * terminal CLOSEKEY returns ecore::EChar:
	 * 	'}'
	 * ;
	 */
	protected String getCLOSEKEYToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "}";
	}
	
	/**
	 * terminal CLOSEPARENTHESIS returns ecore::EChar:
	 * 	')'
	 * ;
	 */
	protected String getCLOSEPARENTHESISToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ")";
	}
	
	/**
	 * terminal COMMA returns ecore::EChar:
	 * 	','
	 * ;
	 */
	protected String getCOMMAToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ",";
	}
	
	/**
	 * DecrementLoopExpression returns ecore::EString:
	 * 	INT "--" | Identifier "--"
	 * ;
	 */
	protected String getDecrementLoopExpressionToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "--";
	}
	
	/**
	 * terminal ELSE returns ecore::EString:
	 * 	"else"
	 * ;
	 */
	protected String getELSEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "else";
	}
	
	/**
	 * terminal EMIT returns ecore::EString:
	 * 	"emit"
	 * ;
	 */
	protected String getEMITToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "emit";
	}
	
	/**
	 * terminal EOLINE returns ecore::EString:
	 * 	"/n"
	 * ;
	 */
	protected String getEOLINEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "/n";
	}
	
	/**
	 * terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	 */
	protected String getIDToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "";
	}
	
	/**
	 * terminal IF returns ecore::EString:
	 * 	"if"
	 * ;
	 */
	protected String getIFToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "if";
	}
	
	/**
	 * Identifier returns ecore::EString:
	 * 	(ID|CHAR)
	 * ;
	 */
	protected String getIdentifierToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "";
	}
	
	/**
	 * IdentifierValueExpression returns ecore::EString:
	 * 	Identifier DOT Identifier 
	 * ;
	 */
	protected String getIdentifierValueExpressionToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ".";
	}
	
	/**
	 * IncrementLoopExpression returns ecore::EString:
	 * 	INT "++" | Identifier "++"
	 * ;
	 */
	protected String getIncrementLoopExpressionToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "++";
	}
	
	/**
	 * LogicalUnaryOperator returns ecore::EString:
	 * 	 "!"
	 * ;
	 */
	protected String getLogicalUnaryOperatorToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "!";
	}
	
	/**
	 * terminal OPENKEY returns ecore::EChar:
	 * 	'{'
	 * ;
	 */
	protected String getOPENKEYToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "{";
	}
	
	/**
	 * terminal OPENPARENTHESIS returns ecore::EChar:
	 * 	'('
	 * ;
	 */
	protected String getOPENPARENTHESISToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "(";
	}
	
	/**
	 * terminal RETURNS returns ecore::EString:
	 * 	"returns"
	 * ;
	 */
	protected String getRETURNSToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "returns";
	}
	
	/**
	 * terminal SEMICOLON returns ecore::EChar:
	 * 	';'
	 * ;
	 */
	protected String getSEMICOLONToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ";";
	}
	
	/**
	 * SingularType:
	 * 	
	 * 	TypeUint| TypeInt | TypeAddress | TypeDouble | TypeBool | TypeBytes |TypeString
	 * ;
	 */
	protected String getSingularTypeToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "uint";
	}
	
	@Override
	protected void emitUnassignedTokens(EObject semanticObject, ISynTransition transition, INode fromNode, INode toNode) {
		if (transition.getAmbiguousSyntaxes().isEmpty()) return;
		List<INode> transitionNodes = collectNodes(fromNode, toNode);
		for (AbstractElementAlias syntax : transition.getAmbiguousSyntaxes()) {
			List<INode> syntaxNodes = getNodesFor(transitionNodes, syntax);
			if (match_AbstractContract_COMMATerminalRuleCall_2_1_1_q.equals(syntax))
				emit_AbstractContract_COMMATerminalRuleCall_2_1_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_AbstractContract_EOLINETerminalRuleCall_10_q.equals(syntax))
				emit_AbstractContract_EOLINETerminalRuleCall_10_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_AbstractContract_EOLINETerminalRuleCall_4_q.equals(syntax))
				emit_AbstractContract_EOLINETerminalRuleCall_4_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_AbstractContract_IsKeyword_2_0_q.equals(syntax))
				emit_AbstractContract_IsKeyword_2_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Assert_EOLINETerminalRuleCall_5_q.equals(syntax))
				emit_Assert_EOLINETerminalRuleCall_5_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Assert_LogicalUnaryOperatorParserRuleCall_2_0_0_0_q.equals(syntax))
				emit_Assert_LogicalUnaryOperatorParserRuleCall_2_0_0_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Assert_LogicalUnaryOperatorParserRuleCall_2_0_1_1_0_q.equals(syntax))
				emit_Assert_LogicalUnaryOperatorParserRuleCall_2_0_1_1_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Clause_EOLINETerminalRuleCall_13_q.equals(syntax))
				emit_Clause_EOLINETerminalRuleCall_13_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Clause_EOLINETerminalRuleCall_14_6_1_q.equals(syntax))
				emit_Clause_EOLINETerminalRuleCall_14_6_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Clause_EOLINETerminalRuleCall_14_8_6_q.equals(syntax))
				emit_Clause_EOLINETerminalRuleCall_14_8_6_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Clause_EOLINETerminalRuleCall_16_q.equals(syntax))
				emit_Clause_EOLINETerminalRuleCall_16_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Clause___OPENPARENTHESISTerminalRuleCall_14_8_2_CLOSEPARENTHESISTerminalRuleCall_14_8_4_SEMICOLONTerminalRuleCall_14_8_5_EOLINETerminalRuleCall_14_8_6_q_EMITTerminalRuleCall_14_8_0__q.equals(syntax))
				emit_Clause___OPENPARENTHESISTerminalRuleCall_14_8_2_CLOSEPARENTHESISTerminalRuleCall_14_8_4_SEMICOLONTerminalRuleCall_14_8_5_EOLINETerminalRuleCall_14_8_6_q_EMITTerminalRuleCall_14_8_0__q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Clause___OPENPARENTHESISTerminalRuleCall_8_1_0_CLOSEPARENTHESISTerminalRuleCall_8_1_2__q.equals(syntax))
				emit_Clause___OPENPARENTHESISTerminalRuleCall_8_1_0_CLOSEPARENTHESISTerminalRuleCall_8_1_2__q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Clause___RETURNSTerminalRuleCall_11_0_OPENPARENTHESISTerminalRuleCall_11_1_CLOSEPARENTHESISTerminalRuleCall_11_3__q.equals(syntax))
				emit_Clause___RETURNSTerminalRuleCall_11_0_OPENPARENTHESISTerminalRuleCall_11_1_CLOSEPARENTHESISTerminalRuleCall_11_3__q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Company_EOLINETerminalRuleCall_12_q.equals(syntax))
				emit_Company_EOLINETerminalRuleCall_12_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Company_EOLINETerminalRuleCall_16_q.equals(syntax))
				emit_Company_EOLINETerminalRuleCall_16_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Company_EOLINETerminalRuleCall_20_q.equals(syntax))
				emit_Company_EOLINETerminalRuleCall_20_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Company_EOLINETerminalRuleCall_25_q.equals(syntax))
				emit_Company_EOLINETerminalRuleCall_25_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Company_EOLINETerminalRuleCall_4_q.equals(syntax))
				emit_Company_EOLINETerminalRuleCall_4_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Company_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_Company_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Condition_EOLINETerminalRuleCall_5_q.equals(syntax))
				emit_Condition_EOLINETerminalRuleCall_5_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Condition_EOLINETerminalRuleCall_6_6_6_q.equals(syntax))
				emit_Condition_EOLINETerminalRuleCall_6_6_6_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Condition_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_Condition_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Condition_EOLINETerminalRuleCall_9_2_q.equals(syntax))
				emit_Condition_EOLINETerminalRuleCall_9_2_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Condition_EOLINETerminalRuleCall_9_3_6_6_q.equals(syntax))
				emit_Condition_EOLINETerminalRuleCall_9_3_6_6_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Condition_EOLINETerminalRuleCall_9_5_q.equals(syntax))
				emit_Condition_EOLINETerminalRuleCall_9_5_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Condition___ELSETerminalRuleCall_9_0_OPENKEYTerminalRuleCall_9_1_EOLINETerminalRuleCall_9_2_q_CLOSEKEYTerminalRuleCall_9_4_EOLINETerminalRuleCall_9_5_q__q.equals(syntax))
				emit_Condition___ELSETerminalRuleCall_9_0_OPENKEYTerminalRuleCall_9_1_EOLINETerminalRuleCall_9_2_q_CLOSEKEYTerminalRuleCall_9_4_EOLINETerminalRuleCall_9_5_q__q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Constructor_EOLINETerminalRuleCall_11_q.equals(syntax))
				emit_Constructor_EOLINETerminalRuleCall_11_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Constructor_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_Constructor_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Constructor_SEMICOLONTerminalRuleCall_9_4_1_q.equals(syntax))
				emit_Constructor_SEMICOLONTerminalRuleCall_9_4_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Contract_AsteriskKeyword_5_6_3_3_or_BracketExpressionParserRuleCall_5_6_3_2_or_IdentifierParserRuleCall_5_6_3_0_or_IdentifierValueExpressionParserRuleCall_5_6_3_1_or_SingularTypeParserRuleCall_5_6_3_4.equals(syntax))
				emit_Contract_AsteriskKeyword_5_6_3_3_or_BracketExpressionParserRuleCall_5_6_3_2_or_IdentifierParserRuleCall_5_6_3_0_or_IdentifierValueExpressionParserRuleCall_5_6_3_1_or_SingularTypeParserRuleCall_5_6_3_4(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Contract_COMMATerminalRuleCall_2_1_1_q.equals(syntax))
				emit_Contract_COMMATerminalRuleCall_2_1_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Contract_EOLINETerminalRuleCall_12_q.equals(syntax))
				emit_Contract_EOLINETerminalRuleCall_12_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Contract_EOLINETerminalRuleCall_4_q.equals(syntax))
				emit_Contract_EOLINETerminalRuleCall_4_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Contract_EOLINETerminalRuleCall_5_6_5_q.equals(syntax))
				emit_Contract_EOLINETerminalRuleCall_5_6_5_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Contract_IsKeyword_2_0_q.equals(syntax))
				emit_Contract_IsKeyword_2_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Contract___ForKeyword_5_6_2___AsteriskKeyword_5_6_3_3_or_BracketExpressionParserRuleCall_5_6_3_2_or_IdentifierParserRuleCall_5_6_3_0_or_IdentifierValueExpressionParserRuleCall_5_6_3_1_or_SingularTypeParserRuleCall_5_6_3_4___SEMICOLONTerminalRuleCall_5_6_4_EOLINETerminalRuleCall_5_6_5_q_UsingKeyword_5_6_0__q.equals(syntax))
				emit_Contract___ForKeyword_5_6_2___AsteriskKeyword_5_6_3_3_or_BracketExpressionParserRuleCall_5_6_3_2_or_IdentifierParserRuleCall_5_6_3_0_or_IdentifierValueExpressionParserRuleCall_5_6_3_1_or_SingularTypeParserRuleCall_5_6_3_4___SEMICOLONTerminalRuleCall_5_6_4_EOLINETerminalRuleCall_5_6_5_q_UsingKeyword_5_6_0__q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_DeclarationFunctionAbstractContract_EOLINETerminalRuleCall_10_q.equals(syntax))
				emit_DeclarationFunctionAbstractContract_EOLINETerminalRuleCall_10_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_DeclarationFunctionInterface_EOLINETerminalRuleCall_9_q.equals(syntax))
				emit_DeclarationFunctionInterface_EOLINETerminalRuleCall_9_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_DeclarationFunctionInterface_ExternalKeyword_5_q.equals(syntax))
				emit_DeclarationFunctionInterface_ExternalKeyword_5_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_DoWhileLoop_EOLINETerminalRuleCall_10_q.equals(syntax))
				emit_DoWhileLoop_EOLINETerminalRuleCall_10_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_DoWhileLoop_EOLINETerminalRuleCall_2_q.equals(syntax))
				emit_DoWhileLoop_EOLINETerminalRuleCall_2_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Enum_COMMATerminalRuleCall_3_1_q.equals(syntax))
				emit_Enum_COMMATerminalRuleCall_3_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Enum_EOLINETerminalRuleCall_5_q.equals(syntax))
				emit_Enum_EOLINETerminalRuleCall_5_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Error_EOLINETerminalRuleCall_6_q.equals(syntax))
				emit_Error_EOLINETerminalRuleCall_6_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Event_EOLINETerminalRuleCall_6_q.equals(syntax))
				emit_Event_EOLINETerminalRuleCall_6_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ForLoop_DecrementLoopExpressionParserRuleCall_6_1_or_IncrementLoopExpressionParserRuleCall_6_0.equals(syntax))
				emit_ForLoop_DecrementLoopExpressionParserRuleCall_6_1_or_IncrementLoopExpressionParserRuleCall_6_0(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ForLoop_EOLINETerminalRuleCall_11_5_1_q.equals(syntax))
				emit_ForLoop_EOLINETerminalRuleCall_11_5_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ForLoop_EOLINETerminalRuleCall_13_q.equals(syntax))
				emit_ForLoop_EOLINETerminalRuleCall_13_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ForLoop_EOLINETerminalRuleCall_9_q.equals(syntax))
				emit_ForLoop_EOLINETerminalRuleCall_9_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Import_EOLINETerminalRuleCall_0_3_q.equals(syntax))
				emit_Import_EOLINETerminalRuleCall_0_3_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Import_EOLINETerminalRuleCall_1_7_q.equals(syntax))
				emit_Import_EOLINETerminalRuleCall_1_7_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Import_EOLINETerminalRuleCall_2_5_q.equals(syntax))
				emit_Import_EOLINETerminalRuleCall_2_5_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_InputParam_COMMATerminalRuleCall_1_q.equals(syntax))
				emit_InputParam_COMMATerminalRuleCall_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Interface_EOLINETerminalRuleCall_3_q.equals(syntax))
				emit_Interface_EOLINETerminalRuleCall_3_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Interface_EOLINETerminalRuleCall_7_q.equals(syntax))
				emit_Interface_EOLINETerminalRuleCall_7_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Mapping_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_Mapping_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Modifier_EOLINETerminalRuleCall_12_q.equals(syntax))
				emit_Modifier_EOLINETerminalRuleCall_12_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Modifier_EOLINETerminalRuleCall_6_q.equals(syntax))
				emit_Modifier_EOLINETerminalRuleCall_6_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Modifier_SEMICOLONTerminalRuleCall_10_0_1_q.equals(syntax))
				emit_Modifier_SEMICOLONTerminalRuleCall_10_0_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Modifier_SEMICOLONTerminalRuleCall_8_0_1_q.equals(syntax))
				emit_Modifier_SEMICOLONTerminalRuleCall_8_0_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_OutputParam_COMMATerminalRuleCall_1_q.equals(syntax))
				emit_OutputParam_COMMATerminalRuleCall_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PersonalizedStruct_EOLINETerminalRuleCall_3_q.equals(syntax))
				emit_PersonalizedStruct_EOLINETerminalRuleCall_3_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PersonalizedStruct_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_PersonalizedStruct_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PropertyAddress_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_PropertyAddress_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PropertyBoolean_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_PropertyBoolean_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PropertyBytes_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_PropertyBytes_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PropertyCompany_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_PropertyCompany_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PropertyFloat_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_PropertyFloat_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PropertyIdentifier_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_PropertyIdentifier_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PropertyInteger_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_PropertyInteger_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PropertyString_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_PropertyString_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PropertyUInteger_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_PropertyUInteger_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_PropertyUser_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_PropertyUser_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_RestrictionGas_EOLINETerminalRuleCall_9_q.equals(syntax))
				emit_RestrictionGas_EOLINETerminalRuleCall_9_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Restriction_EOLINETerminalRuleCall_5_q.equals(syntax))
				emit_Restriction_EOLINETerminalRuleCall_5_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Restriction_LogicalUnaryOperatorParserRuleCall_2_0_0_0_0_q.equals(syntax))
				emit_Restriction_LogicalUnaryOperatorParserRuleCall_2_0_0_0_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Restriction_LogicalUnaryOperatorParserRuleCall_2_0_0_1_1_0_q.equals(syntax))
				emit_Restriction_LogicalUnaryOperatorParserRuleCall_2_0_0_1_1_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_User_EOLINETerminalRuleCall_12_q.equals(syntax))
				emit_User_EOLINETerminalRuleCall_12_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_User_EOLINETerminalRuleCall_16_q.equals(syntax))
				emit_User_EOLINETerminalRuleCall_16_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_User_EOLINETerminalRuleCall_20_q.equals(syntax))
				emit_User_EOLINETerminalRuleCall_20_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_User_EOLINETerminalRuleCall_25_q.equals(syntax))
				emit_User_EOLINETerminalRuleCall_25_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_User_EOLINETerminalRuleCall_4_q.equals(syntax))
				emit_User_EOLINETerminalRuleCall_4_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_User_EOLINETerminalRuleCall_8_q.equals(syntax))
				emit_User_EOLINETerminalRuleCall_8_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Version_EOLINETerminalRuleCall_5_q.equals(syntax))
				emit_Version_EOLINETerminalRuleCall_5_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_WhileLoop_EOLINETerminalRuleCall_5_q.equals(syntax))
				emit_WhileLoop_EOLINETerminalRuleCall_5_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_WhileLoop_EOLINETerminalRuleCall_9_q.equals(syntax))
				emit_WhileLoop_EOLINETerminalRuleCall_9_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else acceptNodes(getLastNavigableState(), syntaxNodes);
		}
	}

	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     COMMA?
	 *
	 * This ambiguous syntax occurs at:
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? CLOSEKEY EOLINE? (rule end)
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? clauses+=DeclarationFunctionAbstractContract
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? errors+=Error
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? events+=Event
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? modifiers+=Modifier
	 *     superType+=[Element|ID] (ambiguity) superType+=[Element|ID]
	 
	 * </pre>
	 */
	protected void emit_AbstractContract_COMMATerminalRuleCall_2_1_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     clauses+=DeclarationFunctionAbstractContract CLOSEKEY (ambiguity) (rule end)
	 *     errors+=Error CLOSEKEY (ambiguity) (rule end)
	 *     events+=Event CLOSEKEY (ambiguity) (rule end)
	 *     modifiers+=Modifier CLOSEKEY (ambiguity) (rule end)
	 *     name=Identifier 'is'? OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     superType+=[Element|ID] COMMA? OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_AbstractContract_EOLINETerminalRuleCall_10_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     name=Identifier 'is'? OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     name=Identifier 'is'? OPENKEY (ambiguity) clauses+=DeclarationFunctionAbstractContract
	 *     name=Identifier 'is'? OPENKEY (ambiguity) errors+=Error
	 *     name=Identifier 'is'? OPENKEY (ambiguity) events+=Event
	 *     name=Identifier 'is'? OPENKEY (ambiguity) modifiers+=Modifier
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) clauses+=DeclarationFunctionAbstractContract
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) errors+=Error
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) events+=Event
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) modifiers+=Modifier
	 
	 * </pre>
	 */
	protected void emit_AbstractContract_EOLINETerminalRuleCall_4_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     'is'?
	 *
	 * This ambiguous syntax occurs at:
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? CLOSEKEY EOLINE? (rule end)
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? clauses+=DeclarationFunctionAbstractContract
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? errors+=Error
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? events+=Event
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? modifiers+=Modifier
	 
	 * </pre>
	 */
	protected void emit_AbstractContract_IsKeyword_2_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     expr1='now' CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1='now' CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=ArithmeticalExpression CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=ArithmeticalExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=BlockVariables CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=BracketExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=Identifier CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=Identifier CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=IdentifierValueExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=MSGSENDER CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=MSGSENDER CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=MSGVALUE CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=MSGVALUE CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=NumberExpression CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=NumberExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=SyntaxExpression CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=SyntaxExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2='now' CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=ArithmeticalExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=Identifier CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=MSGSENDER CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=MSGVALUE CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=NumberExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=SyntaxExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Assert_EOLINETerminalRuleCall_5_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     LogicalUnaryOperator?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) 'assert' OPENPARENTHESIS (ambiguity) expr1='now'
	 *     (rule start) 'assert' OPENPARENTHESIS (ambiguity) expr1=ArithmeticalExpression
	 *     (rule start) 'assert' OPENPARENTHESIS (ambiguity) expr1=BracketExpression
	 *     (rule start) 'assert' OPENPARENTHESIS (ambiguity) expr1=Identifier
	 *     (rule start) 'assert' OPENPARENTHESIS (ambiguity) expr1=IdentifierValueExpression
	 *     (rule start) 'assert' OPENPARENTHESIS (ambiguity) expr1=MSGSENDER
	 *     (rule start) 'assert' OPENPARENTHESIS (ambiguity) expr1=MSGVALUE
	 *     (rule start) 'assert' OPENPARENTHESIS (ambiguity) expr1=NumberExpression
	 *     (rule start) 'assert' OPENPARENTHESIS (ambiguity) expr1=SyntaxExpression
	 
	 * </pre>
	 */
	protected void emit_Assert_LogicalUnaryOperatorParserRuleCall_2_0_0_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     LogicalUnaryOperator?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) 'assert' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1='now'
	 *     (rule start) 'assert' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=ArithmeticalExpression
	 *     (rule start) 'assert' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=BlockVariables
	 *     (rule start) 'assert' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=Identifier
	 *     (rule start) 'assert' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=MSGSENDER
	 *     (rule start) 'assert' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=MSGVALUE
	 *     (rule start) 'assert' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=NumberExpression
	 *     (rule start) 'assert' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=SyntaxExpression
	 
	 * </pre>
	 */
	protected void emit_Assert_LogicalUnaryOperatorParserRuleCall_2_0_1_1_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) conditions+=Condition
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) expressions+=Expression
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) mappingProperties+=Mapping
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) predefinedFunctions+=PredefinedFunctions
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) properties+=Properties
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     outputParams+=OutputParam CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     outputParams+=OutputParam CLOSEPARENTHESIS OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     outputParams+=OutputParam CLOSEPARENTHESIS OPENKEY (ambiguity) conditions+=Condition
	 *     outputParams+=OutputParam CLOSEPARENTHESIS OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     outputParams+=OutputParam CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=Expression
	 *     outputParams+=OutputParam CLOSEPARENTHESIS OPENKEY (ambiguity) mappingProperties+=Mapping
	 *     outputParams+=OutputParam CLOSEPARENTHESIS OPENKEY (ambiguity) predefinedFunctions+=PredefinedFunctions
	 *     outputParams+=OutputParam CLOSEPARENTHESIS OPENKEY (ambiguity) properties+=Properties
	 *     outputParams+=OutputParam CLOSEPARENTHESIS OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     outputParams+=OutputParam CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     override=OverrideModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     override=OverrideModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     override=OverrideModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) conditions+=Condition
	 *     override=OverrideModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     override=OverrideModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) expressions+=Expression
	 *     override=OverrideModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) mappingProperties+=Mapping
	 *     override=OverrideModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) predefinedFunctions+=PredefinedFunctions
	 *     override=OverrideModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) properties+=Properties
	 *     override=OverrideModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     override=OverrideModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) conditions+=Condition
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) expressions+=Expression
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) mappingProperties+=Mapping
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) predefinedFunctions+=PredefinedFunctions
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) properties+=Properties
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     predefinedModifier=InputModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     predefinedModifier=InputModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     predefinedModifier=InputModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) conditions+=Condition
	 *     predefinedModifier=InputModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     predefinedModifier=InputModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) expressions+=Expression
	 *     predefinedModifier=InputModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) mappingProperties+=Mapping
	 *     predefinedModifier=InputModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) predefinedFunctions+=PredefinedFunctions
	 *     predefinedModifier=InputModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) properties+=Properties
	 *     predefinedModifier=InputModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     predefinedModifier=InputModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     visibilityAccess=Visibility (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     visibilityAccess=Visibility (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     visibilityAccess=Visibility (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) conditions+=Condition
	 *     visibilityAccess=Visibility (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     visibilityAccess=Visibility (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) expressions+=Expression
	 *     visibilityAccess=Visibility (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) mappingProperties+=Mapping
	 *     visibilityAccess=Visibility (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) predefinedFunctions+=PredefinedFunctions
	 *     visibilityAccess=Visibility (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) properties+=Properties
	 *     visibilityAccess=Visibility (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     visibilityAccess=Visibility (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 
	 * </pre>
	 */
	protected void emit_Clause_EOLINETerminalRuleCall_13_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     expressions+=Expression (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     expressions+=Expression (ambiguity) EMIT event+=[Event|ID]
	 *     expressions+=Expression (ambiguity) conditions+=Condition
	 *     expressions+=Expression (ambiguity) determinedloops+=ForLoop
	 *     expressions+=Expression (ambiguity) expressions+=Expression
	 *     expressions+=Expression (ambiguity) mappingProperties+=Mapping
	 *     expressions+=Expression (ambiguity) predefinedFunctions+=PredefinedFunctions
	 *     expressions+=Expression (ambiguity) properties+=Properties
	 *     expressions+=Expression (ambiguity) restriction+=RestrictionClause
	 *     expressions+=Expression (ambiguity) undeterminedloops+=UnDeterminedLoop
	 
	 * </pre>
	 */
	protected void emit_Clause_EOLINETerminalRuleCall_14_6_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) conditions+=Condition
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) determinedloops+=ForLoop
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) expressions+=Expression
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) mappingProperties+=Mapping
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) predefinedFunctions+=PredefinedFunctions
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) properties+=Properties
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) restriction+=RestrictionClause
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) EMIT event+=[Event|ID]
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) conditions+=Condition
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) determinedloops+=ForLoop
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) expressions+=Expression
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) mappingProperties+=Mapping
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) predefinedFunctions+=PredefinedFunctions
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) properties+=Properties
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) restriction+=RestrictionClause
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) undeterminedloops+=UnDeterminedLoop
	 
	 * </pre>
	 */
	protected void emit_Clause_EOLINETerminalRuleCall_14_8_6_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     conditions+=Condition CLOSEKEY (ambiguity) (rule end)
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) (rule end)
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     expressions+=Expression EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     mappingProperties+=Mapping CLOSEKEY (ambiguity) (rule end)
	 *     outputParams+=OutputParam CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     override=OverrideModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     predefinedFunctions+=PredefinedFunctions CLOSEKEY (ambiguity) (rule end)
	 *     predefinedModifier=InputModifier (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     properties+=Properties CLOSEKEY (ambiguity) (rule end)
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) (rule end)
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) (rule end)
	 *     visibilityAccess=Visibility (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Clause_EOLINETerminalRuleCall_16_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     (OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? EMIT)?
	 *
	 * This ambiguous syntax occurs at:
	 *     event+=[Event|ID] (ambiguity) event+=[Event|ID]
	 
	 * </pre>
	 */
	protected void emit_Clause___OPENPARENTHESISTerminalRuleCall_14_8_2_CLOSEPARENTHESISTerminalRuleCall_14_8_4_SEMICOLONTerminalRuleCall_14_8_5_EOLINETerminalRuleCall_14_8_6_q_EMITTerminalRuleCall_14_8_0__q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     (OPENPARENTHESIS CLOSEPARENTHESIS)?
	 *
	 * This ambiguous syntax occurs at:
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? CLOSEKEY EOLINE? (rule end)
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? EMIT event+=[Event|ID]
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? conditions+=Condition
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? determinedloops+=ForLoop
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? expressions+=Expression
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? mappingProperties+=Mapping
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? predefinedFunctions+=PredefinedFunctions
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? properties+=Properties
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? restriction+=RestrictionClause
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)? OPENKEY EOLINE? undeterminedloops+=UnDeterminedLoop
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) RETURNS OPENPARENTHESIS outputParams+=OutputParam
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) override=OverrideModifier
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) personalizedModifier+=[Modifier|ID]
	 *     personalizedModifier+=[Modifier|ID] (ambiguity) predefinedModifier=InputModifier
	 
	 * </pre>
	 */
	protected void emit_Clause___OPENPARENTHESISTerminalRuleCall_8_1_0_CLOSEPARENTHESISTerminalRuleCall_8_1_2__q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     (RETURNS OPENPARENTHESIS CLOSEPARENTHESIS)?
	 *
	 * This ambiguous syntax occurs at:
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (ambiguity) OPENKEY EOLINE? CLOSEKEY EOLINE? (rule end)
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (ambiguity) OPENKEY EOLINE? EMIT event+=[Event|ID]
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (ambiguity) OPENKEY EOLINE? conditions+=Condition
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (ambiguity) OPENKEY EOLINE? determinedloops+=ForLoop
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (ambiguity) OPENKEY EOLINE? expressions+=Expression
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (ambiguity) OPENKEY EOLINE? mappingProperties+=Mapping
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (ambiguity) OPENKEY EOLINE? predefinedFunctions+=PredefinedFunctions
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (ambiguity) OPENKEY EOLINE? properties+=Properties
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (ambiguity) OPENKEY EOLINE? restriction+=RestrictionClause
	 *     inputParamsModifier+=InputParam CLOSEPARENTHESIS (ambiguity) OPENKEY EOLINE? undeterminedloops+=UnDeterminedLoop
	 *     override=OverrideModifier (ambiguity) OPENKEY EOLINE? CLOSEKEY EOLINE? (rule end)
	 *     override=OverrideModifier (ambiguity) OPENKEY EOLINE? EMIT event+=[Event|ID]
	 *     override=OverrideModifier (ambiguity) OPENKEY EOLINE? conditions+=Condition
	 *     override=OverrideModifier (ambiguity) OPENKEY EOLINE? determinedloops+=ForLoop
	 *     override=OverrideModifier (ambiguity) OPENKEY EOLINE? expressions+=Expression
	 *     override=OverrideModifier (ambiguity) OPENKEY EOLINE? mappingProperties+=Mapping
	 *     override=OverrideModifier (ambiguity) OPENKEY EOLINE? predefinedFunctions+=PredefinedFunctions
	 *     override=OverrideModifier (ambiguity) OPENKEY EOLINE? properties+=Properties
	 *     override=OverrideModifier (ambiguity) OPENKEY EOLINE? restriction+=RestrictionClause
	 *     override=OverrideModifier (ambiguity) OPENKEY EOLINE? undeterminedloops+=UnDeterminedLoop
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (ambiguity) OPENKEY EOLINE? CLOSEKEY EOLINE? (rule end)
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (ambiguity) OPENKEY EOLINE? EMIT event+=[Event|ID]
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (ambiguity) OPENKEY EOLINE? conditions+=Condition
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (ambiguity) OPENKEY EOLINE? determinedloops+=ForLoop
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (ambiguity) OPENKEY EOLINE? expressions+=Expression
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (ambiguity) OPENKEY EOLINE? mappingProperties+=Mapping
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (ambiguity) OPENKEY EOLINE? predefinedFunctions+=PredefinedFunctions
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (ambiguity) OPENKEY EOLINE? properties+=Properties
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (ambiguity) OPENKEY EOLINE? restriction+=RestrictionClause
	 *     personalizedModifier+=[Modifier|ID] (OPENPARENTHESIS CLOSEPARENTHESIS)? (ambiguity) OPENKEY EOLINE? undeterminedloops+=UnDeterminedLoop
	 *     predefinedModifier=InputModifier (ambiguity) OPENKEY EOLINE? CLOSEKEY EOLINE? (rule end)
	 *     predefinedModifier=InputModifier (ambiguity) OPENKEY EOLINE? EMIT event+=[Event|ID]
	 *     predefinedModifier=InputModifier (ambiguity) OPENKEY EOLINE? conditions+=Condition
	 *     predefinedModifier=InputModifier (ambiguity) OPENKEY EOLINE? determinedloops+=ForLoop
	 *     predefinedModifier=InputModifier (ambiguity) OPENKEY EOLINE? expressions+=Expression
	 *     predefinedModifier=InputModifier (ambiguity) OPENKEY EOLINE? mappingProperties+=Mapping
	 *     predefinedModifier=InputModifier (ambiguity) OPENKEY EOLINE? predefinedFunctions+=PredefinedFunctions
	 *     predefinedModifier=InputModifier (ambiguity) OPENKEY EOLINE? properties+=Properties
	 *     predefinedModifier=InputModifier (ambiguity) OPENKEY EOLINE? restriction+=RestrictionClause
	 *     predefinedModifier=InputModifier (ambiguity) OPENKEY EOLINE? undeterminedloops+=UnDeterminedLoop
	 *     visibilityAccess=Visibility (ambiguity) OPENKEY EOLINE? CLOSEKEY EOLINE? (rule end)
	 *     visibilityAccess=Visibility (ambiguity) OPENKEY EOLINE? EMIT event+=[Event|ID]
	 *     visibilityAccess=Visibility (ambiguity) OPENKEY EOLINE? conditions+=Condition
	 *     visibilityAccess=Visibility (ambiguity) OPENKEY EOLINE? determinedloops+=ForLoop
	 *     visibilityAccess=Visibility (ambiguity) OPENKEY EOLINE? expressions+=Expression
	 *     visibilityAccess=Visibility (ambiguity) OPENKEY EOLINE? mappingProperties+=Mapping
	 *     visibilityAccess=Visibility (ambiguity) OPENKEY EOLINE? predefinedFunctions+=PredefinedFunctions
	 *     visibilityAccess=Visibility (ambiguity) OPENKEY EOLINE? properties+=Properties
	 *     visibilityAccess=Visibility (ambiguity) OPENKEY EOLINE? restriction+=RestrictionClause
	 *     visibilityAccess=Visibility (ambiguity) OPENKEY EOLINE? undeterminedloops+=UnDeterminedLoop
	 
	 * </pre>
	 */
	protected void emit_Clause___RETURNSTerminalRuleCall_11_0_OPENPARENTHESISTerminalRuleCall_11_1_CLOSEPARENTHESISTerminalRuleCall_11_3__q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     nameAttributeCompany=Identifier SEMICOLON (ambiguity) 'string' nameAttributeCity=Identifier
	 
	 * </pre>
	 */
	protected void emit_Company_EOLINETerminalRuleCall_12_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     nameAttributeCity=Identifier SEMICOLON (ambiguity) 'string' emailAttributeCompany=Identifier
	 
	 * </pre>
	 */
	protected void emit_Company_EOLINETerminalRuleCall_16_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     emailAttributeCompany=Identifier SEMICOLON (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     emailAttributeCompany=Identifier SEMICOLON (ambiguity) mapping+=Mapping
	 *     emailAttributeCompany=Identifier SEMICOLON (ambiguity) properties+=Properties
	 *     emailAttributeCompany=Identifier SEMICOLON (ambiguity) structs+=PersonalizedStruct
	 
	 * </pre>
	 */
	protected void emit_Company_EOLINETerminalRuleCall_20_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     emailAttributeCompany=Identifier SEMICOLON EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     mapping+=Mapping CLOSEKEY (ambiguity) (rule end)
	 *     properties+=Properties CLOSEKEY (ambiguity) (rule end)
	 *     structs+=PersonalizedStruct CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Company_EOLINETerminalRuleCall_25_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     name='Company' OPENKEY (ambiguity) 'address ' nameAttributeAddress=Identifier
	 
	 * </pre>
	 */
	protected void emit_Company_EOLINETerminalRuleCall_4_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     nameAttributeAddress=Identifier SEMICOLON (ambiguity) 'string' nameAttributeCompany=Identifier
	 
	 * </pre>
	 */
	protected void emit_Company_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) conditionalExpr+=Condition
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=BREAK
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=CONTINUE
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=Expression
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) properties+=Properties
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) conditionalExpr+=Condition
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=BREAK
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=CONTINUE
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=Expression
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) properties+=Properties
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) conditionalExpr+=Condition
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=BREAK
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=CONTINUE
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=Expression
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) properties+=Properties
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) conditionalExpr+=Condition
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=BREAK
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=CONTINUE
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=Expression
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) properties+=Properties
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) conditionalExpr+=Condition
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=BREAK
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=CONTINUE
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=Expression
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) properties+=Properties
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) conditionalExpr+=Condition
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=BREAK
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=CONTINUE
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=Expression
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) properties+=Properties
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) conditionalExpr+=Condition
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=BREAK
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=CONTINUE
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=Expression
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) properties+=Properties
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) conditionalExpr+=Condition
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=BREAK
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=CONTINUE
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=Expression
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) properties+=Properties
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) EMIT event+=[Event|ID]
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) conditionalExpr+=Condition
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) determinedloops+=ForLoop
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=BREAK
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=CONTINUE
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) expressions+=Expression
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) properties+=Properties
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) restriction+=RestrictionClause
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedloops+=UnDeterminedLoop
	 
	 * </pre>
	 */
	protected void emit_Condition_EOLINETerminalRuleCall_5_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) EMIT event+=[Event|ID]
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) conditionalExpr+=Condition
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) determinedloops+=ForLoop
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) expressions+=BREAK
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) expressions+=CONTINUE
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) expressions+=Expression
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) properties+=Properties
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) restriction+=RestrictionClause
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) EMIT event+=[Event|ID]
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) conditionalExpr+=Condition
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) determinedloops+=ForLoop
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) expressions+=BREAK
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) expressions+=CONTINUE
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) expressions+=Expression
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) properties+=Properties
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) restriction+=RestrictionClause
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) undeterminedloops+=UnDeterminedLoop
	 
	 * </pre>
	 */
	protected void emit_Condition_EOLINETerminalRuleCall_6_6_6_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     conditionalExpr+=Condition CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     conditionalExpr+=Condition CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     conditionalExpr+=Condition CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     conditionalExpr+=Condition CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     conditionalExpr+=Condition CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     conditionalExpr+=Condition CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     conditionalExpr+=Condition CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     conditionalExpr+=Condition CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     conditionalExpr+=Condition CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     conditionalExpr+=Condition CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     expressions+=BREAK CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     expressions+=BREAK CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     expressions+=BREAK CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     expressions+=BREAK CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     expressions+=BREAK CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     expressions+=BREAK CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     expressions+=BREAK CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     expressions+=BREAK CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     expressions+=BREAK CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     expressions+=BREAK CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     expressions+=CONTINUE CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     expressions+=CONTINUE CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     expressions+=CONTINUE CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     expressions+=CONTINUE CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     expressions+=CONTINUE CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     expressions+=CONTINUE CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     expressions+=CONTINUE CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     expressions+=CONTINUE CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     expressions+=CONTINUE CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     expressions+=CONTINUE CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     expressions+=Expression CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     expressions+=Expression CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     expressions+=Expression CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     expressions+=Expression CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     expressions+=Expression CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     expressions+=Expression CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     expressions+=Expression CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     expressions+=Expression CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     expressions+=Expression CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     expressions+=Expression CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     properties+=Properties CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     properties+=Properties CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     properties+=Properties CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     properties+=Properties CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     properties+=Properties CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     properties+=Properties CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     properties+=Properties CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     properties+=Properties CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     properties+=Properties CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     properties+=Properties CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)? (rule end)
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? EMIT eventElse+=[Event|ID]
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? conditionalExprElse+=Condition
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? determinedloopsElse+=ForLoop
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=BREAK
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=CONTINUE
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? expressionsElse+=Expression
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? propertiesElse+=Properties
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? restrictionElse+=RestrictionClause
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) ELSE OPENKEY EOLINE? undeterminedloopsElse+=UnDeterminedLoop
	 
	 * </pre>
	 */
	protected void emit_Condition_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     conditionalExpr+=Condition CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     conditionalExpr+=Condition CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     conditionalExpr+=Condition CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     conditionalExpr+=Condition CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     conditionalExpr+=Condition CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     conditionalExpr+=Condition CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     conditionalExpr+=Condition CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     conditionalExpr+=Condition CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     conditionalExpr+=Condition CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     determinedloops+=ForLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     determinedloops+=ForLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     determinedloops+=ForLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     determinedloops+=ForLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     determinedloops+=ForLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     determinedloops+=ForLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     determinedloops+=ForLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     determinedloops+=ForLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     determinedloops+=ForLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     expressions+=BREAK CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     expressions+=BREAK CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     expressions+=BREAK CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     expressions+=BREAK CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     expressions+=BREAK CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     expressions+=BREAK CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     expressions+=BREAK CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     expressions+=BREAK CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     expressions+=BREAK CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     expressions+=CONTINUE CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     expressions+=CONTINUE CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     expressions+=CONTINUE CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     expressions+=CONTINUE CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     expressions+=CONTINUE CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     expressions+=CONTINUE CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     expressions+=CONTINUE CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     expressions+=CONTINUE CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     expressions+=CONTINUE CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     expressions+=Expression CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     expressions+=Expression CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     expressions+=Expression CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     expressions+=Expression CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     expressions+=Expression CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     expressions+=Expression CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     expressions+=Expression CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     expressions+=Expression CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     expressions+=Expression CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     properties+=Properties CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     properties+=Properties CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     properties+=Properties CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     properties+=Properties CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     properties+=Properties CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     properties+=Properties CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     properties+=Properties CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     properties+=Properties CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     properties+=Properties CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     restriction+=RestrictionClause CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     restriction+=RestrictionClause CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     restriction+=RestrictionClause CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     restriction+=RestrictionClause CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     restriction+=RestrictionClause CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     restriction+=RestrictionClause CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     restriction+=RestrictionClause CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     restriction+=RestrictionClause CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     restriction+=RestrictionClause CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) EMIT eventElse+=[Event|ID]
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) conditionalExprElse+=Condition
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) determinedloopsElse+=ForLoop
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=BREAK
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=CONTINUE
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) expressionsElse+=Expression
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) propertiesElse+=Properties
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) restrictionElse+=RestrictionClause
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY EOLINE? ELSE OPENKEY (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 
	 * </pre>
	 */
	protected void emit_Condition_EOLINETerminalRuleCall_9_2_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     eventElse+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     eventElse+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) EMIT eventElse+=[Event|ID]
	 *     eventElse+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) conditionalExprElse+=Condition
	 *     eventElse+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) determinedloopsElse+=ForLoop
	 *     eventElse+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) expressionsElse+=BREAK
	 *     eventElse+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) expressionsElse+=CONTINUE
	 *     eventElse+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) expressionsElse+=Expression
	 *     eventElse+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) propertiesElse+=Properties
	 *     eventElse+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) restrictionElse+=RestrictionClause
	 *     eventElse+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 *     inputParamsEventElse+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     inputParamsEventElse+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) EMIT eventElse+=[Event|ID]
	 *     inputParamsEventElse+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) conditionalExprElse+=Condition
	 *     inputParamsEventElse+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) determinedloopsElse+=ForLoop
	 *     inputParamsEventElse+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) expressionsElse+=BREAK
	 *     inputParamsEventElse+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) expressionsElse+=CONTINUE
	 *     inputParamsEventElse+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) expressionsElse+=Expression
	 *     inputParamsEventElse+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) propertiesElse+=Properties
	 *     inputParamsEventElse+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) restrictionElse+=RestrictionClause
	 *     inputParamsEventElse+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) undeterminedloopsElse+=UnDeterminedLoop
	 
	 * </pre>
	 */
	protected void emit_Condition_EOLINETerminalRuleCall_9_3_6_6_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     conditionalExprElse+=Condition CLOSEKEY (ambiguity) (rule end)
	 *     determinedloopsElse+=ForLoop CLOSEKEY (ambiguity) (rule end)
	 *     eventElse+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     expressionsElse+=BREAK CLOSEKEY (ambiguity) (rule end)
	 *     expressionsElse+=CONTINUE CLOSEKEY (ambiguity) (rule end)
	 *     expressionsElse+=Expression CLOSEKEY (ambiguity) (rule end)
	 *     inputParamsEventElse+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     propertiesElse+=Properties CLOSEKEY (ambiguity) (rule end)
	 *     restrictionElse+=RestrictionClause CLOSEKEY (ambiguity) (rule end)
	 *     undeterminedloopsElse+=UnDeterminedLoop CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Condition_EOLINETerminalRuleCall_9_5_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     (ELSE OPENKEY EOLINE? CLOSEKEY EOLINE?)?
	 *
	 * This ambiguous syntax occurs at:
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     condition=BracketExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     condition=CryptographycFunctionsComparationExpresion CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     condition=LogicalComparationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     condition=NegationExpression CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     conditionalExpr+=Condition CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     determinedloops+=ForLoop CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     expressions+=BREAK CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     expressions+=CONTINUE CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     expressions+=Expression CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     inputParamsEvent+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE? CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     properties+=Properties CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     restriction+=RestrictionClause CLOSEKEY EOLINE? (ambiguity) (rule end)
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY EOLINE? (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Condition___ELSETerminalRuleCall_9_0_OPENKEYTerminalRuleCall_9_1_EOLINETerminalRuleCall_9_2_q_CLOSEKEYTerminalRuleCall_9_4_EOLINETerminalRuleCall_9_5_q__q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) 'constructor' OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule start)
	 *     attributesInitialization+=Expression SEMICOLON? CLOSEKEY (ambiguity) (rule end)
	 *     conditions+=Condition CLOSEKEY (ambiguity) (rule end)
	 *     constructorContractInherance+=[Contract|ID] OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     determinedLoops+=ForLoop CLOSEKEY (ambiguity) (rule end)
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     inputParamsConstructorContractInherance+=InputParam CLOSEPARENTHESIS OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     payable='payable' OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     restrictions+=Assert CLOSEKEY (ambiguity) (rule end)
	 *     restrictions+=Restriction CLOSEKEY (ambiguity) (rule end)
	 *     restrictions+=RestrictionGas CLOSEKEY (ambiguity) (rule end)
	 *     type='internal' OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     type='public' OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     undeterminedLoops+=UnDeterminedLoop CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Constructor_EOLINETerminalRuleCall_11_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) 'constructor' OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule start)
	 *     (rule start) 'constructor' OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) attributesInitialization+=Expression
	 *     (rule start) 'constructor' OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) conditions+=Condition
	 *     (rule start) 'constructor' OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) determinedLoops+=ForLoop
	 *     (rule start) 'constructor' OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) restrictions+=Assert
	 *     (rule start) 'constructor' OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) restrictions+=Restriction
	 *     (rule start) 'constructor' OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) restrictions+=RestrictionGas
	 *     (rule start) 'constructor' OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedLoops+=UnDeterminedLoop
	 *     constructorContractInherance+=[Contract|ID] OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     constructorContractInherance+=[Contract|ID] OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) attributesInitialization+=Expression
	 *     constructorContractInherance+=[Contract|ID] OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) conditions+=Condition
	 *     constructorContractInherance+=[Contract|ID] OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) determinedLoops+=ForLoop
	 *     constructorContractInherance+=[Contract|ID] OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) restrictions+=Assert
	 *     constructorContractInherance+=[Contract|ID] OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) restrictions+=Restriction
	 *     constructorContractInherance+=[Contract|ID] OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) restrictions+=RestrictionGas
	 *     constructorContractInherance+=[Contract|ID] OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedLoops+=UnDeterminedLoop
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) attributesInitialization+=Expression
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) conditions+=Condition
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) determinedLoops+=ForLoop
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) restrictions+=Assert
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) restrictions+=Restriction
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) restrictions+=RestrictionGas
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedLoops+=UnDeterminedLoop
	 *     inputParamsConstructorContractInherance+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     inputParamsConstructorContractInherance+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) attributesInitialization+=Expression
	 *     inputParamsConstructorContractInherance+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) conditions+=Condition
	 *     inputParamsConstructorContractInherance+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) determinedLoops+=ForLoop
	 *     inputParamsConstructorContractInherance+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) restrictions+=Assert
	 *     inputParamsConstructorContractInherance+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) restrictions+=Restriction
	 *     inputParamsConstructorContractInherance+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) restrictions+=RestrictionGas
	 *     inputParamsConstructorContractInherance+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) undeterminedLoops+=UnDeterminedLoop
	 *     payable='payable' OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     payable='payable' OPENKEY (ambiguity) attributesInitialization+=Expression
	 *     payable='payable' OPENKEY (ambiguity) conditions+=Condition
	 *     payable='payable' OPENKEY (ambiguity) determinedLoops+=ForLoop
	 *     payable='payable' OPENKEY (ambiguity) restrictions+=Assert
	 *     payable='payable' OPENKEY (ambiguity) restrictions+=Restriction
	 *     payable='payable' OPENKEY (ambiguity) restrictions+=RestrictionGas
	 *     payable='payable' OPENKEY (ambiguity) undeterminedLoops+=UnDeterminedLoop
	 *     type='internal' OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     type='internal' OPENKEY (ambiguity) attributesInitialization+=Expression
	 *     type='internal' OPENKEY (ambiguity) conditions+=Condition
	 *     type='internal' OPENKEY (ambiguity) determinedLoops+=ForLoop
	 *     type='internal' OPENKEY (ambiguity) restrictions+=Assert
	 *     type='internal' OPENKEY (ambiguity) restrictions+=Restriction
	 *     type='internal' OPENKEY (ambiguity) restrictions+=RestrictionGas
	 *     type='internal' OPENKEY (ambiguity) undeterminedLoops+=UnDeterminedLoop
	 *     type='public' OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     type='public' OPENKEY (ambiguity) attributesInitialization+=Expression
	 *     type='public' OPENKEY (ambiguity) conditions+=Condition
	 *     type='public' OPENKEY (ambiguity) determinedLoops+=ForLoop
	 *     type='public' OPENKEY (ambiguity) restrictions+=Assert
	 *     type='public' OPENKEY (ambiguity) restrictions+=Restriction
	 *     type='public' OPENKEY (ambiguity) restrictions+=RestrictionGas
	 *     type='public' OPENKEY (ambiguity) undeterminedLoops+=UnDeterminedLoop
	 
	 * </pre>
	 */
	protected void emit_Constructor_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     SEMICOLON?
	 *
	 * This ambiguous syntax occurs at:
	 *     attributesInitialization+=Expression (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     attributesInitialization+=Expression (ambiguity) attributesInitialization+=Expression
	 *     attributesInitialization+=Expression (ambiguity) conditions+=Condition
	 *     attributesInitialization+=Expression (ambiguity) determinedLoops+=ForLoop
	 *     attributesInitialization+=Expression (ambiguity) restrictions+=Assert
	 *     attributesInitialization+=Expression (ambiguity) restrictions+=Restriction
	 *     attributesInitialization+=Expression (ambiguity) restrictions+=RestrictionGas
	 *     attributesInitialization+=Expression (ambiguity) undeterminedLoops+=UnDeterminedLoop
	 
	 * </pre>
	 */
	protected void emit_Constructor_SEMICOLONTerminalRuleCall_9_4_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType
	 *
	 * This ambiguous syntax occurs at:
	 *     libraries+=[Library|ID] 'for' (ambiguity) SEMICOLON EOLINE? CLOSEKEY EOLINE? (rule end)
	 *     libraries+=[Library|ID] 'for' (ambiguity) SEMICOLON EOLINE? clauses+=Clause
	 *     libraries+=[Library|ID] 'for' (ambiguity) SEMICOLON EOLINE? constructors+=Constructor
	 *     libraries+=[Library|ID] 'for' (ambiguity) SEMICOLON EOLINE? errors+=Error
	 *     libraries+=[Library|ID] 'for' (ambiguity) SEMICOLON EOLINE? events+=Event
	 *     libraries+=[Library|ID] 'for' (ambiguity) SEMICOLON EOLINE? localEnumerators+=Enum
	 *     libraries+=[Library|ID] 'for' (ambiguity) SEMICOLON EOLINE? localMappingProperties+=Mapping
	 *     libraries+=[Library|ID] 'for' (ambiguity) SEMICOLON EOLINE? localProperties+=Properties
	 *     libraries+=[Library|ID] 'for' (ambiguity) SEMICOLON EOLINE? modifiers+=Modifier
	 *     libraries+=[Library|ID] 'for' (ambiguity) SEMICOLON EOLINE? structCompany=Company
	 *     libraries+=[Library|ID] 'for' (ambiguity) SEMICOLON EOLINE? structUser=User
	 *     libraries+=[Library|ID] 'for' (ambiguity) SEMICOLON EOLINE? structs+=PersonalizedStruct
	 
	 * </pre>
	 */
	protected void emit_Contract_AsteriskKeyword_5_6_3_3_or_BracketExpressionParserRuleCall_5_6_3_2_or_IdentifierParserRuleCall_5_6_3_0_or_IdentifierValueExpressionParserRuleCall_5_6_3_1_or_SingularTypeParserRuleCall_5_6_3_4(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     COMMA?
	 *
	 * This ambiguous syntax occurs at:
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? 'using' libraries+=[Library|ID]
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? CLOSEKEY EOLINE? (rule end)
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? clauses+=Clause
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? constructors+=Constructor
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? errors+=Error
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? events+=Event
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? localEnumerators+=Enum
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? localMappingProperties+=Mapping
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? localProperties+=Properties
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? modifiers+=Modifier
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? structCompany=Company
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? structUser=User
	 *     superType+=[Element|ID] (ambiguity) OPENKEY EOLINE? structs+=PersonalizedStruct
	 *     superType+=[Element|ID] (ambiguity) superType+=[Element|ID]
	 
	 * </pre>
	 */
	protected void emit_Contract_COMMATerminalRuleCall_2_1_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     clauses+=Clause CLOSEKEY (ambiguity) (rule end)
	 *     constructors+=Constructor CLOSEKEY (ambiguity) (rule end)
	 *     errors+=Error CLOSEKEY (ambiguity) (rule end)
	 *     events+=Event CLOSEKEY (ambiguity) (rule end)
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     localEnumerators+=Enum CLOSEKEY (ambiguity) (rule end)
	 *     localMappingProperties+=Mapping CLOSEKEY (ambiguity) (rule end)
	 *     localProperties+=Properties CLOSEKEY (ambiguity) (rule end)
	 *     modifiers+=Modifier CLOSEKEY (ambiguity) (rule end)
	 *     name=Identifier 'is'? OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     structCompany=Company CLOSEKEY (ambiguity) (rule end)
	 *     structUser=User CLOSEKEY (ambiguity) (rule end)
	 *     structs+=PersonalizedStruct CLOSEKEY (ambiguity) (rule end)
	 *     superType+=[Element|ID] COMMA? OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Contract_EOLINETerminalRuleCall_12_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     name=Identifier 'is'? OPENKEY (ambiguity) 'using' libraries+=[Library|ID]
	 *     name=Identifier 'is'? OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     name=Identifier 'is'? OPENKEY (ambiguity) clauses+=Clause
	 *     name=Identifier 'is'? OPENKEY (ambiguity) constructors+=Constructor
	 *     name=Identifier 'is'? OPENKEY (ambiguity) errors+=Error
	 *     name=Identifier 'is'? OPENKEY (ambiguity) events+=Event
	 *     name=Identifier 'is'? OPENKEY (ambiguity) localEnumerators+=Enum
	 *     name=Identifier 'is'? OPENKEY (ambiguity) localMappingProperties+=Mapping
	 *     name=Identifier 'is'? OPENKEY (ambiguity) localProperties+=Properties
	 *     name=Identifier 'is'? OPENKEY (ambiguity) modifiers+=Modifier
	 *     name=Identifier 'is'? OPENKEY (ambiguity) structCompany=Company
	 *     name=Identifier 'is'? OPENKEY (ambiguity) structUser=User
	 *     name=Identifier 'is'? OPENKEY (ambiguity) structs+=PersonalizedStruct
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) 'using' libraries+=[Library|ID]
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) clauses+=Clause
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) constructors+=Constructor
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) errors+=Error
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) events+=Event
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) localEnumerators+=Enum
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) localMappingProperties+=Mapping
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) localProperties+=Properties
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) modifiers+=Modifier
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) structCompany=Company
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) structUser=User
	 *     superType+=[Element|ID] COMMA? OPENKEY (ambiguity) structs+=PersonalizedStruct
	 
	 * </pre>
	 */
	protected void emit_Contract_EOLINETerminalRuleCall_4_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON (ambiguity) clauses+=Clause
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON (ambiguity) constructors+=Constructor
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON (ambiguity) errors+=Error
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON (ambiguity) events+=Event
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON (ambiguity) localEnumerators+=Enum
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON (ambiguity) localMappingProperties+=Mapping
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON (ambiguity) localProperties+=Properties
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON (ambiguity) modifiers+=Modifier
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON (ambiguity) structCompany=Company
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON (ambiguity) structUser=User
	 *     libraries+=[Library|ID] 'for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON (ambiguity) structs+=PersonalizedStruct
	 
	 * </pre>
	 */
	protected void emit_Contract_EOLINETerminalRuleCall_5_6_5_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     'is'?
	 *
	 * This ambiguous syntax occurs at:
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? 'using' libraries+=[Library|ID]
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? CLOSEKEY EOLINE? (rule end)
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? clauses+=Clause
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? constructors+=Constructor
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? errors+=Error
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? events+=Event
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? localEnumerators+=Enum
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? localMappingProperties+=Mapping
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? localProperties+=Properties
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? modifiers+=Modifier
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? structCompany=Company
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? structUser=User
	 *     name=Identifier (ambiguity) OPENKEY EOLINE? structs+=PersonalizedStruct
	 
	 * </pre>
	 */
	protected void emit_Contract_IsKeyword_2_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     ('for' (Identifier | IdentifierValueExpression | BracketExpression | '*' | SingularType) SEMICOLON EOLINE? 'using')?
	 *
	 * This ambiguous syntax occurs at:
	 *     libraries+=[Library|ID] (ambiguity) libraries+=[Library|ID]
	 
	 * </pre>
	 */
	protected void emit_Contract___ForKeyword_5_6_2___AsteriskKeyword_5_6_3_3_or_BracketExpressionParserRuleCall_5_6_3_2_or_IdentifierParserRuleCall_5_6_3_0_or_IdentifierValueExpressionParserRuleCall_5_6_3_1_or_SingularTypeParserRuleCall_5_6_3_4___SEMICOLONTerminalRuleCall_5_6_4_EOLINETerminalRuleCall_5_6_5_q_UsingKeyword_5_6_0__q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     modifier='payable' SEMICOLON (ambiguity) (rule end)
	 *     modifier='view' SEMICOLON (ambiguity) (rule end)
	 *     outputParams+=OutputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     virtual=VIRTUAL SEMICOLON (ambiguity) (rule end)
	 *     visibility=Visibility SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_DeclarationFunctionAbstractContract_EOLINETerminalRuleCall_10_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inputParams+=InputParam CLOSEPARENTHESIS 'external'? SEMICOLON (ambiguity) (rule end)
	 *     modifier='payable' SEMICOLON (ambiguity) (rule end)
	 *     modifier='view' SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS 'external'? SEMICOLON (ambiguity) (rule end)
	 *     outputParams+=OutputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_DeclarationFunctionInterface_EOLINETerminalRuleCall_9_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     'external'?
	 *
	 * This ambiguous syntax occurs at:
	 *     inputParams+=InputParam CLOSEPARENTHESIS (ambiguity) RETURNS OPENPARENTHESIS outputParams+=OutputParam
	 *     inputParams+=InputParam CLOSEPARENTHESIS (ambiguity) SEMICOLON EOLINE? (rule end)
	 *     inputParams+=InputParam CLOSEPARENTHESIS (ambiguity) modifier='payable'
	 *     inputParams+=InputParam CLOSEPARENTHESIS (ambiguity) modifier='view'
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS (ambiguity) RETURNS OPENPARENTHESIS outputParams+=OutputParam
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS (ambiguity) SEMICOLON EOLINE? (rule end)
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS (ambiguity) modifier='payable'
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS (ambiguity) modifier='view'
	 
	 * </pre>
	 */
	protected void emit_DeclarationFunctionInterface_ExternalKeyword_5_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     condition=AndExpression CLOSEPARENTHESIS (ambiguity) (rule end)
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS (ambiguity) (rule end)
	 *     condition=BoolValueExpression CLOSEPARENTHESIS (ambiguity) (rule end)
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS (ambiguity) (rule end)
	 *     condition=ComparationExpression CLOSEPARENTHESIS (ambiguity) (rule end)
	 *     condition=OrExpression CLOSEPARENTHESIS (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_DoWhileLoop_EOLINETerminalRuleCall_10_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) 'do' OPENKEY (ambiguity) gasrestriction+=RestrictionGas
	 
	 * </pre>
	 */
	protected void emit_DoWhileLoop_EOLINETerminalRuleCall_2_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     COMMA?
	 *
	 * This ambiguous syntax occurs at:
	 *     values+=Identifier (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     values+=Identifier (ambiguity) values+=Identifier
	 
	 * </pre>
	 */
	protected void emit_Enum_COMMATerminalRuleCall_3_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     nameEnumerator=Identifier OPENKEY CLOSEKEY (ambiguity) (rule end)
	 *     values+=Identifier COMMA? CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Enum_EOLINETerminalRuleCall_5_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inputParams+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Error_EOLINETerminalRuleCall_6_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inputParams+=InputParam CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Event_EOLINETerminalRuleCall_6_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     IncrementLoopExpression | DecrementLoopExpression
	 *
	 * This ambiguous syntax occurs at:
	 *     condition=ArithmeticalComparationExpression SEMICOLON (ambiguity) CLOSEPARENTHESIS OPENKEY EOLINE? gasrestriction+=RestrictionGas
	 
	 * </pre>
	 */
	protected void emit_ForLoop_DecrementLoopExpressionParserRuleCall_6_1_or_IncrementLoopExpressionParserRuleCall_6_0(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     expressions+=BREAK (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     expressions+=BREAK (ambiguity) conditions+=Condition
	 *     expressions+=BREAK (ambiguity) determinedloops+=ForLoop
	 *     expressions+=BREAK (ambiguity) expressions+=BREAK
	 *     expressions+=BREAK (ambiguity) expressions+=CONTINUE
	 *     expressions+=BREAK (ambiguity) expressions+=Expression
	 *     expressions+=BREAK (ambiguity) properties+=Properties
	 *     expressions+=BREAK (ambiguity) restriction+=RestrictionClause
	 *     expressions+=BREAK (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     expressions+=CONTINUE (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     expressions+=CONTINUE (ambiguity) conditions+=Condition
	 *     expressions+=CONTINUE (ambiguity) determinedloops+=ForLoop
	 *     expressions+=CONTINUE (ambiguity) expressions+=BREAK
	 *     expressions+=CONTINUE (ambiguity) expressions+=CONTINUE
	 *     expressions+=CONTINUE (ambiguity) expressions+=Expression
	 *     expressions+=CONTINUE (ambiguity) properties+=Properties
	 *     expressions+=CONTINUE (ambiguity) restriction+=RestrictionClause
	 *     expressions+=CONTINUE (ambiguity) undeterminedloops+=UnDeterminedLoop
	 *     expressions+=Expression (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     expressions+=Expression (ambiguity) conditions+=Condition
	 *     expressions+=Expression (ambiguity) determinedloops+=ForLoop
	 *     expressions+=Expression (ambiguity) expressions+=BREAK
	 *     expressions+=Expression (ambiguity) expressions+=CONTINUE
	 *     expressions+=Expression (ambiguity) expressions+=Expression
	 *     expressions+=Expression (ambiguity) properties+=Properties
	 *     expressions+=Expression (ambiguity) restriction+=RestrictionClause
	 *     expressions+=Expression (ambiguity) undeterminedloops+=UnDeterminedLoop
	 
	 * </pre>
	 */
	protected void emit_ForLoop_EOLINETerminalRuleCall_11_5_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     conditions+=Condition CLOSEKEY (ambiguity) (rule end)
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) (rule end)
	 *     expressions+=BREAK EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     expressions+=CONTINUE EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     expressions+=Expression EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     gasrestriction+=RestrictionGas CLOSEKEY (ambiguity) (rule end)
	 *     properties+=Properties CLOSEKEY (ambiguity) (rule end)
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) (rule end)
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_ForLoop_EOLINETerminalRuleCall_13_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     condition=ArithmeticalComparationExpression SEMICOLON (IncrementLoopExpression | DecrementLoopExpression) CLOSEPARENTHESIS OPENKEY (ambiguity) gasrestriction+=RestrictionGas
	 
	 * </pre>
	 */
	protected void emit_ForLoop_EOLINETerminalRuleCall_9_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     name=SyntaxExpression SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Import_EOLINETerminalRuleCall_0_3_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     name=SyntaxExpression SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Import_EOLINETerminalRuleCall_1_7_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     alias=Identifier SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Import_EOLINETerminalRuleCall_2_5_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     COMMA?
	 *
	 * This ambiguous syntax occurs at:
	 *     array=Array CLOSEPARENTHESIS (ambiguity) (rule end)
	 *     value='Company' CLOSEPARENTHESIS (ambiguity) (rule end)
	 *     value='User' CLOSEPARENTHESIS (ambiguity) (rule end)
	 *     value=Identifier CLOSEPARENTHESIS (ambiguity) (rule end)
	 *     value=SingularType CLOSEPARENTHESIS (ambiguity) (rule end)
	 *     valueIdentifier=MappingDeclaration CLOSEPARENTHESIS (ambiguity) (rule end)
	 *     valueInput=ArithmeticalComparationExpression (ambiguity) (rule end)
	 *     valueInput=ArithmeticalExpression (ambiguity) (rule end)
	 *     valueInput=BlockVariables (ambiguity) (rule end)
	 *     valueInput=BoolValueExpression (ambiguity) (rule end)
	 *     valueInput=CoinExpression (ambiguity) (rule end)
	 *     valueInput=Identifier (ambiguity) (rule end)
	 *     valueInput=IdentifierDotExpression (ambiguity) (rule end)
	 *     valueInput=MSGVariables (ambiguity) (rule end)
	 *     valueInput=NumberExpression (ambiguity) (rule end)
	 *     valueInput=SyntaxExpression (ambiguity) (rule end)
	 *     valueInput=TxVariables (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_InputParam_COMMATerminalRuleCall_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     name=Identifier OPENKEY (ambiguity) interfaceEvents+=Event
	 *     name=Identifier OPENKEY (ambiguity) interfaceFunction+=DeclarationFunctionInterface
	 
	 * </pre>
	 */
	protected void emit_Interface_EOLINETerminalRuleCall_3_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     interfaceFunction+=DeclarationFunctionInterface CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Interface_EOLINETerminalRuleCall_7_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inicialization=Identifier SEMICOLON (ambiguity) (rule end)
	 *     inicialization=NumberExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=SyntaxExpression SEMICOLON (ambiguity) (rule end)
	 *     nameMapping=Identifier SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Mapping_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     conditionRestricion+=Assert '_;' CLOSEKEY (ambiguity) (rule end)
	 *     conditionRestricion+=Restriction '_;' CLOSEKEY (ambiguity) (rule end)
	 *     conditionRestricion+=RestrictionGas '_;' CLOSEKEY (ambiguity) (rule end)
	 *     conditionsAfterMark+=Condition CLOSEKEY (ambiguity) (rule end)
	 *     conditionsBeforeMark+=Condition '_;' CLOSEKEY (ambiguity) (rule end)
	 *     expressionsAssignValueAfterMark+=AssignExpression SEMICOLON? CLOSEKEY (ambiguity) (rule end)
	 *     expressionsAssignValueBeforeMark+=AssignExpression SEMICOLON? '_;' CLOSEKEY (ambiguity) (rule end)
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY EOLINE? '_;' CLOSEKEY (ambiguity) (rule end)
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY EOLINE? '_;' CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Modifier_EOLINETerminalRuleCall_12_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) '_;' CLOSEKEY EOLINE? (rule end)
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) '_;' conditionsAfterMark+=Condition
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) '_;' expressionsAssignValueAfterMark+=AssignExpression
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) conditionRestricion+=Assert
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) conditionRestricion+=Restriction
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) conditionRestricion+=RestrictionGas
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) conditionsBeforeMark+=Condition
	 *     inputParams+=InputParam CLOSEPARENTHESIS OPENKEY (ambiguity) expressionsAssignValueBeforeMark+=AssignExpression
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) '_;' CLOSEKEY EOLINE? (rule end)
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) '_;' conditionsAfterMark+=Condition
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) '_;' expressionsAssignValueAfterMark+=AssignExpression
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) conditionRestricion+=Assert
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) conditionRestricion+=Restriction
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) conditionRestricion+=RestrictionGas
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) conditionsBeforeMark+=Condition
	 *     name=Identifier OPENPARENTHESIS CLOSEPARENTHESIS OPENKEY (ambiguity) expressionsAssignValueBeforeMark+=AssignExpression
	 
	 * </pre>
	 */
	protected void emit_Modifier_EOLINETerminalRuleCall_6_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     SEMICOLON?
	 *
	 * This ambiguous syntax occurs at:
	 *     expressionsAssignValueAfterMark+=AssignExpression (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     expressionsAssignValueAfterMark+=AssignExpression (ambiguity) conditionsAfterMark+=Condition
	 *     expressionsAssignValueAfterMark+=AssignExpression (ambiguity) expressionsAssignValueAfterMark+=AssignExpression
	 
	 * </pre>
	 */
	protected void emit_Modifier_SEMICOLONTerminalRuleCall_10_0_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     SEMICOLON?
	 *
	 * This ambiguous syntax occurs at:
	 *     expressionsAssignValueBeforeMark+=AssignExpression (ambiguity) '_;' CLOSEKEY EOLINE? (rule end)
	 *     expressionsAssignValueBeforeMark+=AssignExpression (ambiguity) '_;' conditionsAfterMark+=Condition
	 *     expressionsAssignValueBeforeMark+=AssignExpression (ambiguity) '_;' expressionsAssignValueAfterMark+=AssignExpression
	 *     expressionsAssignValueBeforeMark+=AssignExpression (ambiguity) conditionsBeforeMark+=Condition
	 *     expressionsAssignValueBeforeMark+=AssignExpression (ambiguity) expressionsAssignValueBeforeMark+=AssignExpression
	 
	 * </pre>
	 */
	protected void emit_Modifier_SEMICOLONTerminalRuleCall_8_0_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     COMMA?
	 *
	 * This ambiguous syntax occurs at:
	 *     array=Array (ambiguity) (rule end)
	 *     storageData=StorageData (ambiguity) (rule end)
	 *     type='Company' (ambiguity) (rule end)
	 *     type='User' (ambiguity) (rule end)
	 *     type=Identifier (ambiguity) (rule end)
	 *     type=SingularType (ambiguity) (rule end)
	 *     value=ArithmeticalComparationExpression (ambiguity) (rule end)
	 *     value=ArithmeticalExpression (ambiguity) (rule end)
	 *     value=ComparationExpression (ambiguity) (rule end)
	 *     value=Identifier (ambiguity) (rule end)
	 *     value=IdentifierDotExpression (ambiguity) (rule end)
	 *     value=MSGVariables (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_OutputParam_COMMATerminalRuleCall_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     name=Identifier OPENKEY (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     name=Identifier OPENKEY (ambiguity) mapping+=Mapping
	 *     name=Identifier OPENKEY (ambiguity) properties+=Properties
	 *     name=Identifier OPENKEY (ambiguity) structs+=PersonalizedStruct
	 
	 * </pre>
	 */
	protected void emit_PersonalizedStruct_EOLINETerminalRuleCall_3_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     mapping+=Mapping CLOSEKEY (ambiguity) (rule end)
	 *     name=Identifier OPENKEY EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     properties+=Properties CLOSEKEY (ambiguity) (rule end)
	 *     structs+=PersonalizedStruct CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_PersonalizedStruct_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inicialization=ADDRESSEXPRESION SEMICOLON (ambiguity) (rule end)
	 *     inicialization=BracketExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CallFunctionExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CreateAddressObjectExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=Identifier SEMICOLON (ambiguity) (rule end)
	 *     inicialization=IdentifierValueExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=MSGSENDER SEMICOLON (ambiguity) (rule end)
	 *     inicialization=TypeCastingExpression SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_PropertyAddress_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inicialization=BoolValueExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CallFunctionExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CreateBoolObjectExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=Identifier SEMICOLON (ambiguity) (rule end)
	 *     inicialization=IdentifierValueExpression SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_PropertyBoolean_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inicialization=ADDRESSEXPRESION SEMICOLON (ambiguity) (rule end)
	 *     inicialization=AbyExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CallFunctionExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CreateByteObjectExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=HEXEXPRESSION SEMICOLON (ambiguity) (rule end)
	 *     inicialization=Identifier SEMICOLON (ambiguity) (rule end)
	 *     inicialization=IdentifierValueExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=Sha256Expression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=TypeCastingExpression SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_PropertyBytes_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inicialization=BracketExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=Identifier SEMICOLON (ambiguity) (rule end)
	 *     inicialization=IdentifierValueExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=NewPersonalizedTypeCompanyInicialization SEMICOLON (ambiguity) (rule end)
	 *     inicialization=PersonalizedTypeCompanyInicialization SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_PropertyCompany_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inicialization='now' SEMICOLON (ambiguity) (rule end)
	 *     inicialization=ArithmeticalExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=BracketExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CallFunctionExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=Identifier SEMICOLON (ambiguity) (rule end)
	 *     inicialization=IdentifierDotExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=NumberExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=TypeCastingExpression SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_PropertyFloat_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inicialization=BracketExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=Identifier SEMICOLON (ambiguity) (rule end)
	 *     inicialization=IdentifierValueExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=StructInicializationKeyExpression SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_PropertyIdentifier_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inicialization='now' SEMICOLON (ambiguity) (rule end)
	 *     inicialization=ArithmeticalExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=BracketExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CallFunctionExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CreateIntObjectExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=Identifier SEMICOLON (ambiguity) (rule end)
	 *     inicialization=IdentifierDotExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=NumberExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=TypeCastingExpression SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_PropertyInteger_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inicialization=BracketExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CallFunctionExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CreateStringObjectExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=Identifier SEMICOLON (ambiguity) (rule end)
	 *     inicialization=IdentifierDotExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=SyntaxExpression SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_PropertyString_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inicialization='now' SEMICOLON (ambiguity) (rule end)
	 *     inicialization=ArithmeticalExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=ArrayExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=BCKTIMESTAMP SEMICOLON (ambiguity) (rule end)
	 *     inicialization=BracketExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CallFunctionExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=CreateUintObjectExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=Identifier SEMICOLON (ambiguity) (rule end)
	 *     inicialization=IdentifierValueExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=NumberExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=TypeCastingExpression SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_PropertyUInteger_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     inicialization=BracketExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=Identifier SEMICOLON (ambiguity) (rule end)
	 *     inicialization=IdentifierValueExpression SEMICOLON (ambiguity) (rule end)
	 *     inicialization=NewPersonalizedTypeUserInicialization SEMICOLON (ambiguity) (rule end)
	 *     inicialization=PersonalizedTypeUserInicialization SEMICOLON (ambiguity) (rule end)
	 *     name=Identifier SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_PropertyUser_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     message=SyntaxExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     typeCoin=Coin CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_RestrictionGas_EOLINETerminalRuleCall_9_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     expr1='now' CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1='now' CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=ArithmeticalExpression CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=ArithmeticalExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=BCKTIMESTAMP CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=BlockVariables CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=BoolValueExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=BracketExpression CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=BracketExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=CallFunctionExpression CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=CallFunctionExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=Identifier CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=Identifier CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=IdentifierDotExpression CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=IdentifierDotExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=MSGVariables CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=MSGVariables CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=NumberExpression CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=NumberExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=SyntaxExpression CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=SyntaxExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=TypeCastingExpression CLOSEPARENTHESIS CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr1=TypeCastingExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2='now' CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=ArithmeticalExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=BoolValueExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=BracketExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=CallFunctionExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=Identifier CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=IdentifierDotExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=MSGVariables CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=NumberExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=SyntaxExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     expr2=TypeCastingExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 *     message=SyntaxExpression CLOSEPARENTHESIS SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Restriction_EOLINETerminalRuleCall_5_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     LogicalUnaryOperator?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) 'require' OPENPARENTHESIS (ambiguity) expr1='now'
	 *     (rule start) 'require' OPENPARENTHESIS (ambiguity) expr1=ArithmeticalExpression
	 *     (rule start) 'require' OPENPARENTHESIS (ambiguity) expr1=BCKTIMESTAMP
	 *     (rule start) 'require' OPENPARENTHESIS (ambiguity) expr1=BoolValueExpression
	 *     (rule start) 'require' OPENPARENTHESIS (ambiguity) expr1=BracketExpression
	 *     (rule start) 'require' OPENPARENTHESIS (ambiguity) expr1=CallFunctionExpression
	 *     (rule start) 'require' OPENPARENTHESIS (ambiguity) expr1=Identifier
	 *     (rule start) 'require' OPENPARENTHESIS (ambiguity) expr1=IdentifierDotExpression
	 *     (rule start) 'require' OPENPARENTHESIS (ambiguity) expr1=MSGVariables
	 *     (rule start) 'require' OPENPARENTHESIS (ambiguity) expr1=NumberExpression
	 *     (rule start) 'require' OPENPARENTHESIS (ambiguity) expr1=SyntaxExpression
	 *     (rule start) 'require' OPENPARENTHESIS (ambiguity) expr1=TypeCastingExpression
	 
	 * </pre>
	 */
	protected void emit_Restriction_LogicalUnaryOperatorParserRuleCall_2_0_0_0_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     LogicalUnaryOperator?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) 'require' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1='now'
	 *     (rule start) 'require' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=ArithmeticalExpression
	 *     (rule start) 'require' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=BlockVariables
	 *     (rule start) 'require' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=BracketExpression
	 *     (rule start) 'require' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=CallFunctionExpression
	 *     (rule start) 'require' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=Identifier
	 *     (rule start) 'require' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=IdentifierDotExpression
	 *     (rule start) 'require' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=MSGVariables
	 *     (rule start) 'require' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=NumberExpression
	 *     (rule start) 'require' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=SyntaxExpression
	 *     (rule start) 'require' OPENPARENTHESIS OPENPARENTHESIS (ambiguity) expr1=TypeCastingExpression
	 
	 * </pre>
	 */
	protected void emit_Restriction_LogicalUnaryOperatorParserRuleCall_2_0_0_1_1_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     nameAttributeUser=Identifier SEMICOLON (ambiguity) 'string' nameAttributeSurnameUser=Identifier
	 
	 * </pre>
	 */
	protected void emit_User_EOLINETerminalRuleCall_12_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     nameAttributeSurnameUser=Identifier SEMICOLON (ambiguity) 'string' emailAttributeUser=Identifier
	 
	 * </pre>
	 */
	protected void emit_User_EOLINETerminalRuleCall_16_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     emailAttributeUser=Identifier SEMICOLON (ambiguity) CLOSEKEY EOLINE? (rule end)
	 *     emailAttributeUser=Identifier SEMICOLON (ambiguity) mapping+=Mapping
	 *     emailAttributeUser=Identifier SEMICOLON (ambiguity) properties+=Properties
	 *     emailAttributeUser=Identifier SEMICOLON (ambiguity) structs+=PersonalizedStruct
	 
	 * </pre>
	 */
	protected void emit_User_EOLINETerminalRuleCall_20_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     emailAttributeUser=Identifier SEMICOLON EOLINE? CLOSEKEY (ambiguity) (rule end)
	 *     mapping+=Mapping CLOSEKEY (ambiguity) (rule end)
	 *     properties+=Properties CLOSEKEY (ambiguity) (rule end)
	 *     structs+=PersonalizedStruct CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_User_EOLINETerminalRuleCall_25_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     name='User' OPENKEY (ambiguity) 'address ' nameAttributeAddress=Identifier
	 
	 * </pre>
	 */
	protected void emit_User_EOLINETerminalRuleCall_4_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     nameAttributeAddress=Identifier SEMICOLON (ambiguity) 'string' nameAttributeUser=Identifier
	 
	 * </pre>
	 */
	protected void emit_User_EOLINETerminalRuleCall_8_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     numberVersion2=NUMVERSION SEMICOLON (ambiguity) (rule end)
	 *     numberVersion=NUMVERSION SEMICOLON (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_Version_EOLINETerminalRuleCall_5_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     condition=AndExpression CLOSEPARENTHESIS OPENKEY (ambiguity) gasrestriction+=RestrictionGas
	 *     condition=ArithmeticalComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) gasrestriction+=RestrictionGas
	 *     condition=BoolValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) gasrestriction+=RestrictionGas
	 *     condition=CallFunctionExpression CLOSEPARENTHESIS OPENKEY (ambiguity) gasrestriction+=RestrictionGas
	 *     condition=ComparationExpression CLOSEPARENTHESIS OPENKEY (ambiguity) gasrestriction+=RestrictionGas
	 *     condition=IdentifierValueExpression CLOSEPARENTHESIS OPENKEY (ambiguity) gasrestriction+=RestrictionGas
	 *     condition=OrExpression CLOSEPARENTHESIS OPENKEY (ambiguity) gasrestriction+=RestrictionGas
	 
	 * </pre>
	 */
	protected void emit_WhileLoop_EOLINETerminalRuleCall_5_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * <pre>
	 * Ambiguous syntax:
	 *     EOLINE?
	 *
	 * This ambiguous syntax occurs at:
	 *     conditions+=Condition CLOSEKEY (ambiguity) (rule end)
	 *     determinedloops+=ForLoop CLOSEKEY (ambiguity) (rule end)
	 *     event+=[Event|ID] OPENPARENTHESIS CLOSEPARENTHESIS SEMICOLON EOLINE CLOSEKEY (ambiguity) (rule end)
	 *     expressions+=BREAK CLOSEKEY (ambiguity) (rule end)
	 *     expressions+=CONTINUE CLOSEKEY (ambiguity) (rule end)
	 *     expressions+=Expression CLOSEKEY (ambiguity) (rule end)
	 *     gasrestriction+=RestrictionGas CLOSEKEY (ambiguity) (rule end)
	 *     inputParams+=InputParam CLOSEPARENTHESIS SEMICOLON EOLINE CLOSEKEY (ambiguity) (rule end)
	 *     properties+=Properties CLOSEKEY (ambiguity) (rule end)
	 *     restriction+=RestrictionClause CLOSEKEY (ambiguity) (rule end)
	 *     undeterminedloops+=UnDeterminedLoop CLOSEKEY (ambiguity) (rule end)
	 
	 * </pre>
	 */
	protected void emit_WhileLoop_EOLINETerminalRuleCall_9_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
}
